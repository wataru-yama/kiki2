<script>
// グローバル変数
  let userEmail = 'guest@example.com'; // デフォルト値を事前設定
  let userName = 'ゲスト';  // デフォルト値を事前設定
  let equipmentList = [];
  let rentalData = [];
  let locationsList = [];
  let projectsList = []; // 現場リスト（新規追加）
  let currentView = 'twoweeks'; // 14日表示をデフォルトに変更
  let selectedEquipment = '';
  let undoStack = [];
  let startDate = new Date();
  startDate.setHours(0, 0, 0, 0);
  // グローバル変数に追加
  let isDraggingBar = false;
  let isResizingBar = false;
  let dragBarStartX = 0;
  let dragBarStartWidth = 0;
  let dragBarElement = null;
  let dragBarData = null;
  let dragBarOriginalPosition = null;
  let dragBarMode = null; // 'move', 'resize-start', 'resize-end'
  let currentDropTarget = null;
  let selectedLocation = '';
  let selectedEquipmentWithLocation = '';
  let initialDataLoaded = false; // 貸出データを取得する前に初期設定が完了しているかの変数
  let isSwiping = false; // スワイプ中フラグ
  let swipeEndTime = 0; // スワイプ終了時刻
  // スクロールフラグを追加
  let skipScrollToSelectedEquipment = false;
  // スクロール位置保存用
  let savedScrollPosition = {
    top: 0,
    left: 0
  };
  
  // ドラッグ操作用変数
  let isDragging = false;
  let dragStartCell = null;
  // 設定変数
  let userSettings = {
    showConfirmDialog: true, // デフォルトは表示する
    swipeDelay: 500,        // スワイプ後のモーダル表示抑制時間（ミリ秒）
    cellWidth: 80,          // PCでのセル幅
    mobileCellWidth: 80     // モバイルでのセル幅
  };
  // 最後に削除された機器の復元用
  let lastDeletedEquipment = null;

  // DOM読み込み完了時のイベントリスナー
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded イベント発火');
    
    // ユーザー名を「読み込み中...」に設定
    const usernameElement = document.getElementById('username');
    if (usernameElement) {
      usernameElement.textContent = '読み込み中...';
    }
    
    // モーダル初期化
    initializeModals();
    
    // 初期スタイル追加
    addCustomStyles();
    
    // カレンダードラッグ移動設定
    setupCalendarDrag();
    
    // PC版のボタン修正
    setupManagementButtons();
    
    // PC版フォントサイズスライダー追加
    setupPCFontSizeSlider();
    
    // カレンダーナビゲーションボタン追加
    setupCalendarNavigation();
    
    // モバイル向け特別設定
    setupMobileEvents();
    
    // ユーザー認証チェック（最初に実行）
    checkAuthentication();
    
    // イベントリスナーを設定した後に日付ピッカーも設定
	  setTimeout(() => {
	    setupDatePickers();
	  }, 500);
  });

  function setupCalendarDrag() {
	  // 要素を取得
	  const containerSelector = '.gantt-container';
	  const headerSelectors = [
	    '.gantt-header', 
	    '.gantt-date', 
	    '.gantt-header-wrapper',
	    '#date-headers'
	  ];
	  
	  // マウスイベント用ハンドラ
	  function handleMouseDrag(e) {
	    // ヘッダー部分をクリックした場合のみ処理
	    let isHeaderElement = false;
	    for (const selector of headerSelectors) {
	      if (e.target.closest(selector)) {
	        isHeaderElement = true;
	        break;
	      }
	    }
	    if (!isHeaderElement) return;
	    
	    // コンテナを取得
	    const container = document.querySelector(containerSelector);
	    if (!container) return;
	    
	    // ドラッグ開始位置とスクロール位置を保存
	    const startX = e.clientX;
	    const startScrollLeft = container.scrollLeft;
	    let isDragging = true;
	    
	    // ドラッグ中のスタイル
	    document.body.style.cursor = 'grabbing';
	    e.target.closest(headerSelectors.join(',')).classList.add('dragging');
	    
	    // マウス移動ハンドラ
	    function onMouseMove(moveEvent) {
	      if (!isDragging) return;
	      moveEvent.preventDefault();
	      
	      // 移動距離からスクロール量を計算
	      const dx = moveEvent.clientX - startX;
	      // スクロール位置を更新 (マウスと逆方向にスクロール)
	      container.scrollLeft = startScrollLeft - dx;
	    }
	    
	    // マウスアップハンドラ
	    function onMouseUp() {
	      isDragging = false;
	      document.body.style.cursor = '';
	      
	      // ドラッグ中のスタイルを削除
	      const dragElement = document.querySelector(headerSelectors.join(',') + '.dragging');
	      if (dragElement) {
	        dragElement.classList.remove('dragging');
	      }
	      
	      // イベントリスナーを削除
	      document.removeEventListener('mousemove', onMouseMove);
	      document.removeEventListener('mouseup', onMouseUp);
	    }
	    
	    // イベントリスナーを追加
	    document.addEventListener('mousemove', onMouseMove);
	    document.addEventListener('mouseup', onMouseUp);
	  }
	  
	  // タッチイベント用ハンドラ
	  function handleTouchDrag(e) {
	    // ヘッダー部分のタッチのみ処理
	    let isHeaderElement = false;
	    for (const selector of headerSelectors) {
	      if (e.target.closest(selector)) {
	        isHeaderElement = true;
	        break;
	      }
	    }
	    if (!isHeaderElement) return;
	    
	    // コンテナを取得
	    const container = document.querySelector(containerSelector);
	    if (!container) return;
	    
	    // タッチ開始位置とスクロール位置を保存
	    const startX = e.touches[0].clientX;
	    const startScrollLeft = container.scrollLeft;
	    
	    // ドラッグ中のスタイル
	    e.target.closest(headerSelectors.join(',')).classList.add('dragging');
	    
	    // タッチ移動ハンドラ
	    function onTouchMove(moveEvent) {
	      moveEvent.preventDefault();
	      
	      // 移動距離からスクロール量を計算
	      const dx = moveEvent.touches[0].clientX - startX;
	      // スクロール位置を更新 (タッチと逆方向にスクロール)
	      container.scrollLeft = startScrollLeft - dx;
	    }
	    
	    // タッチ終了ハンドラ
	    function onTouchEnd() {
	      // ドラッグ中のスタイルを削除
	      const dragElement = document.querySelector(headerSelectors.join(',') + '.dragging');
	      if (dragElement) {
	        dragElement.classList.remove('dragging');
	      }
	      
	      // イベントリスナーを削除
	      document.removeEventListener('touchmove', onTouchMove);
	      document.removeEventListener('touchend', onTouchEnd);
	    }
	    
	    // イベントリスナーを追加
	    document.addEventListener('touchmove', onTouchMove, { passive: false });
	    document.addEventListener('touchend', onTouchEnd);
	  }
	  
	  // イベントリスナーを設定
	  document.addEventListener('mousedown', handleMouseDrag);
	  document.addEventListener('touchstart', handleTouchDrag, { passive: false });
	  
	  // 日付ヘッダーのドラッグスタイルを追加
	  const styleElement = document.createElement('style');
	  styleElement.textContent = `
	    .gantt-header.dragging,
	    .gantt-date.dragging,
	    .gantt-header-wrapper.dragging,
	    #date-headers.dragging {
	      cursor: grabbing !important;
	      user-select: none;
	    }
	    
	    .gantt-date:hover {
	      cursor: grab;
	      background-color: rgba(38, 166, 154, 0.1);
	    }
	  `;
	  document.head.appendChild(styleElement);
	}
  
  // モーダル初期化の修正
	function initializeModals() {
	  try {
	    const modalElems = document.querySelectorAll('.modal');
	    const modalOptions = {
	      dismissible: true,
	      opacity: 0.5,
	      inDuration: 300,
	      outDuration: 200,
	      preventScrolling: true,
	      startingTop: '10%',
	      endingTop: '10%'
	    };
	    
	    M.Modal.init(modalElems, modalOptions);
	    console.log('モーダル初期化完了');

	  } catch (error) {
	    console.error('モーダル初期化エラー:', error);
	  }
	}

  // カスタムスタイル追加
  function addCustomStyles() {
    try {
      // ハイライト用スタイル
      const style = document.createElement('style');
      style.textContent = `
        .drag-highlight {
          background-color: rgba(38, 166, 154, 0.3) !important;
        }
        .selected-equipment {
          background-color: #e3f2fd;
        }
      `;
      document.head.appendChild(style);
      console.log('カスタムスタイル追加完了');
    } catch (error) {
      console.error('スタイル追加エラー:', error);
    }
  }

  // ユーザー認証状態をチェックする関数
  function checkAuthentication() {
    console.log('認証チェック開始');
    showLoading();
    
    google.script.run
      .withSuccessHandler(function(userInfo) {
        console.log('認証チェック結果:', userInfo);
        
        if (userInfo && userInfo.authenticated) {
          if (userInfo.isRegistered) {
            // 認証済み＆登録済みユーザー
            userEmail = userInfo.email;
            userName = userInfo.name;
            
            const usernameElement = document.getElementById('username');
            if (usernameElement) {
              usernameElement.textContent = userName;
            }
            
            // データ取得を開始
            setupEventListeners();
            loadUserSettings();
            setupMobileSupport();
            fetchAllData();
          } else {
            // 認証済みだが未登録ユーザー
            showUnregisteredUserMessage(userInfo.email);
          }
        } else {
          // 未認証の場合はログイン画面へリダイレクト
          redirectToLogin();
        }
        
        hideLoading();
      })
      .withFailureHandler(function(error) {
        console.error('認証チェックエラー:', error);
        showAuthenticationError(error);
        hideLoading();
      })
      .getUserInfo();
  }

  // 未登録ユーザーのメッセージを表示
  function showUnregisteredUserMessage(email) {
    // 画面をクリア
    document.body.innerHTML = `
      <div style="max-width: 600px; margin: 100px auto; padding: 20px; text-align: center; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
        <h2 style="color: #d32f2f;">アクセス権限がありません</h2>
        <p>このシステムの利用が許可されていません。</p>
        <p>ログインメールアドレス: <strong>${email || 'unknown'}</strong></p>
        <p style="margin-top: 30px;">システム管理者に連絡して、アクセス権限を申請してください。</p>
        <button onclick="window.location.reload();" style="margin-top: 20px; padding: 10px 20px; background-color: #26a69a; color: white; border: none; border-radius: 4px; cursor: pointer;">再試行</button>
      </div>
    `;
  }

  // 認証エラーを表示
  function showAuthenticationError(error) {
    // 画面をクリア
    document.body.innerHTML = `
      <div style="max-width: 600px; margin: 100px auto; padding: 20px; text-align: center; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
        <h2 style="color: #d32f2f;">認証エラー</h2>
        <p>ログイン処理中にエラーが発生しました。</p>
        <p style="color: #666; font-size: 0.9em;">${error || 'Unknown error'}</p>
        <p style="margin-top: 30px;">ページを再読み込みして再試行してください。</p>
        <button onclick="window.location.reload();" style="margin-top: 20px; padding: 10px 20px; background-color: #26a69a; color: white; border: none; border-radius: 4px; cursor: pointer;">再試行</button>
      </div>
    `;
  }

  // ログイン画面へリダイレクト
  function redirectToLogin() {
    // スクリプトURLを取得
    google.script.run
      .withSuccessHandler(function(url) {
        if (url) {
          // 5秒後にリダイレクト
          document.body.innerHTML = `
            <div style="max-width: 600px; margin: 100px auto; padding: 20px; text-align: center; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
              <h2>ログインが必要です</h2>
              <p>このシステムを使用するにはGoogleアカウントでのログインが必要です。</p>
              <p style="margin-top: 20px;">5秒後にログイン画面に移動します...</p>
              <div style="margin: 20px 0; background-color: #f5f5f5; border-radius: 4px; padding: 10px;">
                <div style="width: 100%; height: 4px; background-color: #e0e0e0; border-radius: 2px;">
                  <div id="progress-bar" style="width: 0%; height: 100%; background-color: #26a69a; border-radius: 2px; transition: width 5s linear;"></div>
                </div>
              </div>
              <a href="${url}" style="display: inline-block; margin-top: 10px; padding: 10px 20px; background-color: #4285f4; color: white; text-decoration: none; border-radius: 4px;">今すぐログイン</a>
            </div>
          `;
          
          // プログレスバーのアニメーション
          setTimeout(() => {
            const bar = document.getElementById('progress-bar');
            if (bar) bar.style.width = '100%';
          }, 100);
          
          // 5秒後にリダイレクト
          setTimeout(() => {
            window.location.href = url;
          }, 5000);
        } else {
          showAuthenticationError('ログインURLの取得に失敗しました');
        }
      })
      .withFailureHandler(function(error) {
        showAuthenticationError('ログインURLの取得に失敗しました: ' + error);
      })
      .getScriptUrl();
  }

  // イベントリスナーの設定
	// イベントリスナーの設定
  function setupEventListeners() {
    try {
      // 機器セレクタの変更イベント
      document.getElementById('equipment-select')?.addEventListener('change', function(e) {
        selectedEquipmentWithLocation = e.target.value;
        const parts = selectedEquipmentWithLocation.split('|');
        selectedEquipment = parts[0]; // 機器管理番号部分
        selectedLocation = parts[1] || ''; // 定置場所部分
        
        // いったんスキップフラグをクリア
        skipScrollToSelectedEquipment = false;
        
        // ガントチャート更新
        updateGanttChart();
        
        // 更新後、確実にスクロールするために遅延実行
        setTimeout(() => {
          scrollToSelectedEquipment();
        }, 1000);
      });
      
      // モバイル向け機器セレクタの変更イベント
      const mobileEquipmentSelect = document.getElementById('mobile-equipment-select');
      if (mobileEquipmentSelect) {
        // 古いイベントリスナーを削除
        const clone = mobileEquipmentSelect.cloneNode(true);
        mobileEquipmentSelect.parentNode.replaceChild(clone, mobileEquipmentSelect);
        
        // 新しいイベントリスナーを追加
        clone.addEventListener('change', function(e) {
          console.log('Mobile equipment select changed:', e.target.value);
          selectedEquipmentWithLocation = e.target.value;
          const parts = selectedEquipmentWithLocation.split('|');
          selectedEquipment = parts[0]; // 機器管理番号部分
          selectedLocation = parts[1] || ''; // 定置場所部分
          updateGanttChart();
          
          // スクロール処理を確実に実行
          setTimeout(() => {
            scrollToSelectedEquipment();
          }, 1000);
        });
      }
      
      // 貸出モーダル保存ボタン
      document.getElementById('save-rental')?.addEventListener('click', saveRental);
      
      // 返却モーダル保存ボタン
      document.getElementById('save-return')?.addEventListener('click', saveReturn);
      
      // 元に戻すボタン
      document.getElementById('undo-button')?.addEventListener('click', function() {
        if (undoStack.length > 0) {
          const action = undoStack.pop();
          executeUndo(action);
          
          // スタックが空になったらボタンを無効化
          if (undoStack.length === 0) {
            this.disabled = true;
          }
        }
      });
      
      // モバイル向け本日ボタン
      document.getElementById('mobile-view-today')?.addEventListener('click', function() {
        startDate = new Date();
        startDate.setHours(0, 0, 0, 0);
        updateGanttChart();
      });
      
      // 現場追加ボタン
      document.getElementById('add-project-btn')?.addEventListener('click', addProject);
      
      // 現場削除ボタン
      document.getElementById('delete-projects-btn')?.addEventListener('click', deleteProjects);
      
      // 機器追加ボタン
      document.getElementById('add-equipment-btn')?.addEventListener('click', addEquipment);
      
      // 機器削除ボタン
      document.getElementById('delete-equipment-btn')?.addEventListener('click', deleteEquipment);
      
      // 機器削除取り消しボタン
      document.getElementById('undo-equipment-delete-btn')?.addEventListener('click', undoEquipmentDelete);
      
      // 設定チェックボックス変更イベント
      document.getElementById('confirm-dialog-checkbox')?.addEventListener('change', function(e) {
        userSettings.showConfirmDialog = e.target.checked;
        saveUserSettings();
      });
      
      // PC表示ボタン
      document.getElementById('toggle-pc-view')?.addEventListener('click', function() {
        document.body.classList.remove('mobile-view');
        updateMobileSettings();
        // スクロール位置をリセット
        savedScrollPosition = { top: 0, left: 0 };
        updateGanttChart();
      });
      
      // モバイル表示ボタン
      document.getElementById('toggle-mobile-view')?.addEventListener('click', function() {
        document.body.classList.add('mobile-view');
        updateMobileSettings();
        // スクロール位置をリセット
        savedScrollPosition = { top: 0, left: 0 };
        updateGanttChart();
      });
      
      // モバイルのUndo
      document.getElementById('mobile-menu-undo')?.addEventListener('click', function() {
        const undoButton = document.getElementById('undo-button');
        if (undoButton && !undoButton.disabled) {
          undoButton.click();
        }
      });
      
      // 管理ボタンを正しく設定
      setupManagementButtons();
      
      console.log('イベントリスナー設定完了');
    } catch (error) {
      console.error('イベントリスナー設定エラー:', error);
    }
  }
  
  // ユーザー情報取得
  function getUserInfo() {
    console.log('ユーザー情報取得開始');
    
    // 即座に「読み込み中...」と表示
    const usernameElement = document.getElementById('username');
    if (usernameElement) {
      usernameElement.textContent = '読み込み中...';
    }
    
    // ユーザー情報リクエスト
    google.script.run
      .withSuccessHandler(function(userInfo) {
        console.log('ユーザー情報取得成功:', userInfo);
        
        if (userInfo && userInfo.authenticated && userInfo.isRegistered) {
          // 認証済み＆登録済みユーザー
          userEmail = userInfo.email || '';
          userName = userInfo.name || userInfo.email || 'ゲスト';
          
          if (usernameElement) {
            usernameElement.textContent = userName;
          }
        } else if (userInfo && userInfo.authenticated && !userInfo.isRegistered) {
          // 認証済みだが未登録
          console.warn('未登録ユーザー:', userInfo.email);
          showUnregisteredUserMessage(userInfo.email);
        } else {
          // 未認証
          console.warn('未認証ユーザー');
          redirectToLogin();
        }
      })
      .withFailureHandler(function(error) {
        console.error('ユーザー情報取得エラー:', error);
        
        if (usernameElement) {
          usernameElement.textContent = 'エラー';
        }
        
        // 5秒後に再試行
        setTimeout(checkAuthentication, 5000);
      })
      .getUserInfo();
  }
  
  // 機材リスト取得
  function getEquipmentList() {
    console.log('機材リスト取得開始');
    
    // ユーザー情報も取得（認証済みなので再確認）
    getUserInfo();
    
    google.script.run
      .withSuccessHandler(function(data) {
        if (data && Array.isArray(data)) {
          equipmentList = data;
          console.log('機材リスト取得成功: ' + data.length + '件');
        } else {
          console.warn('機材リストが空か無効です、空のリストで続行します');
          equipmentList = [];
        }
        
        updateEquipmentSelect();
        
        // 定置場所リスト取得
        getLocationsList();
      })
      .withFailureHandler(function(error) {
        console.error('機材リスト取得失敗:', error);
        equipmentList = [];
        updateEquipmentSelect();
        
        // エラーでも次の処理に進む
        getLocationsList();
      })
      .getEquipmentList();
  }
  
  // 定置場所リスト取得
  function getLocationsList() {
    console.log('定置場所リスト取得開始');
    
    // タイムアウトを設定（10秒後にタイムアウト）
    const timeoutId = setTimeout(function() {
      console.log('定置場所リスト取得がタイムアウトしました');
      // 空のリストで続行
      locationsList = [];
      getProjectsList();
    }, 10000);
    
    google.script.run
      .withSuccessHandler(function(data) {
        // タイムアウトをクリア
        clearTimeout(timeoutId);
        
        if (data && Array.isArray(data)) {
          locationsList = data;
          console.log('定置場所リスト取得成功: ' + data.length + '件');
        } else {
          locationsList = [];
          console.warn('定置場所リストが空です');
        }
        
        // 現場リスト取得
        getProjectsList();
      })
      .withFailureHandler(function(error) {
        // タイムアウトをクリア
        clearTimeout(timeoutId);
        
        console.error('定置場所リスト取得失敗:', error);
        locationsList = [];
        
        // 現場リスト取得
        getProjectsList();
      })
      .getLocationsList();
  }
  
  // 現場リスト取得（新規追加）
  function getProjectsList() {
    console.log('現場リスト取得開始');
    
    // タイムアウトを設定（10秒後にタイムアウト）
    const timeoutId = setTimeout(function() {
      console.log('現場リスト取得がタイムアウトしました');
      // 空のリストで続行
      projectsList = [];
      getRentalData();
      restoreLastSelection();
    }, 10000);
    
    google.script.run
      .withSuccessHandler(function(data) {
        // タイムアウトをクリア
        clearTimeout(timeoutId);
        
        if (data && Array.isArray(data)) {
          projectsList = data;
          console.log('現場リスト取得成功: ' + data.length + '件');
        } else {
          projectsList = [];
          console.warn('現場リストが空です');
        }
        
        // 貸出データを取得
        getRentalData();
        
        // 前回選択していた機材を復元
        restoreLastSelection();
      })
      .withFailureHandler(function(error) {
        // タイムアウトをクリア
        clearTimeout(timeoutId);
        
        console.error('現場リスト取得失敗:', error);
        projectsList = [];
        
        // 貸出データを取得
        getRentalData();
        
        // 前回選択していた機材を復元
        restoreLastSelection();
      })
      .getProjectsList();
  }
  
  // 貸出データ取得
  function getRentalData() {
    console.log('貸出データ取得開始');
    
    // タイムアウトを設定（15秒後にタイムアウト）
    const timeoutId = setTimeout(function() {
      console.log('貸出データ取得がタイムアウトしました');
      
      // 空のリストで続行
      rentalData = [];
      initialDataLoaded = true;
      hideLoading();
      updateGanttChart();
    }, 15000);
    
    google.script.run
      .withSuccessHandler(function(data) {
        // タイムアウトをクリア
        clearTimeout(timeoutId);
        
        if (data && Array.isArray(data)) {
          // 日付文字列をDateオブジェクトに変換して保存
          rentalData = data.map(item => {
            Object.keys(item).forEach(key => {
              if (key === '借用開始日' || key === '借用終了日' || key === '登録日時' || key === '返却日') {
                if (item[key] && typeof item[key] === 'string') {
                  item[key] = new Date(item[key]);
                }
              }
            });
            
            // ステータスが設定されていない場合、返却日に基づいて判定
            if (!item['ステータス']) {
              item['ステータス'] = item['返却日'] ? '返却済み' : '貸出中';
            }
            
            return item;
          });
          
          console.log('貸出データ取得成功: ' + data.length + '件');
        } else {
          rentalData = [];
          console.warn('貸出データが空か無効です');
        }
        
        // データ取得完了フラグをセット
        initialDataLoaded = true;
        
        // ローディング非表示
        hideLoading();
        
        // ガントチャート更新
        updateGanttChart();
      })
      .withFailureHandler(function(error) {
        // タイムアウトをクリア
        clearTimeout(timeoutId);
        
        console.error('貸出データ取得失敗:', error);
        rentalData = [];
        
        // データ取得完了フラグをセット
        initialDataLoaded = true;
        
        // ローディング非表示
        hideLoading();
        
        // ガントチャート更新
        updateGanttChart();
      })
      .getRentalData();
  }
  
  // 機材セレクト更新
  function updateEquipmentSelect() {
    try {
      const select = document.getElementById('equipment-select');
      const mobileSelect = document.getElementById('mobile-equipment-select');
      if (!select) return;
      
      // 既存の選択肢をクリア
      select.innerHTML = '<option value="" disabled selected>機材を選択してください</option>';
      if (mobileSelect) mobileSelect.innerHTML = '<option value="" disabled selected>機材を選択してください</option>';
      
      // 機器ごとにグループ化
      const equipmentGroups = {};
      
      equipmentList.forEach(item => {
        if (!item['機器管理番号'] || !item['機器名称']) return;
        
        const id = item['機器管理番号'];
        if (!equipmentGroups[id]) {
          equipmentGroups[id] = [];
        }
        equipmentGroups[id].push(item);
      });
      
      // グループをあいうえお順でソート
      const sortedGroups = Object.keys(equipmentGroups).sort((a, b) => {
        const itemA = equipmentGroups[a][0];
        const itemB = equipmentGroups[b][0];
        return String(itemA['機器名称']).localeCompare(String(itemB['機器名称']), 'ja');
      });
      
      // 選択肢を追加
      sortedGroups.forEach(groupId => {
        const group = equipmentGroups[groupId];
        const firstItem = group[0];
        
        // 機器ごとに在庫総数を計算
        let totalStock = 0;
        group.forEach(item => {
          totalStock += (parseInt(item['総台数']) || 0);
        });
        
        // 各定置場所ごとの機材を追加
        group.forEach(item => {
          const option = document.createElement('option');
          // 機器管理番号と定置場所を組み合わせたvalue
          option.value = `${item['機器管理番号']}|${item['定置場所'] || ''}`;
          
          // 機器名のみを表示（定置場所は括弧内に小さく表示）
          let locationText = item['定置場所'] || '未設定';
          let displayText = `${item['機器名称']} (${locationText})`;
          
          option.textContent = displayText;
          select.appendChild(option);
          
          // モバイル用も同様
          if (mobileSelect) {
            const mobileOption = option.cloneNode(true);
            mobileSelect.appendChild(mobileOption);
          }
        });
      });
      
      // MaterializeのSelectを初期化
      try {
        M.FormSelect.init(select);
        if (mobileSelect) M.FormSelect.init(mobileSelect);
      } catch (e) {
        console.error('セレクト初期化エラー:', e);
      }
    } catch (error) {
      console.error('機材セレクト更新エラー:', error);
    }
  }
  
  // 1. updateGanttChart関数の修正 - ガントチャートの高さ調整と無限スクロール対応
  function updateGanttChart() {
  try {
    showLoading();
    console.log('ガントチャート更新開始');
    
    // 選択中の機材と定置場所の情報を保存
    saveCurrentSelection();
    
    // 表示する日数を拡張（より多くの日付を表示）
    let endDate = new Date(startDate);
    endDate.setDate(startDate.getDate() + 60); // 60日分表示に拡張
    
    // 日付配列作成
    const days = [];
    const tempDate = new Date(startDate);
    while (tempDate < endDate) {
      days.push(new Date(tempDate));
      tempDate.setDate(tempDate.getDate() + 1);
    }
    
    // モバイル対応のためのレイアウト変更
    if (document.body.classList.contains('mobile-view')) {
      // モバイルレイアウトの作成
      createMobileLayout(days);
    } else {
      // PC向けレイアウトの作成
      createDesktopLayout(days);
    }
    
    // ガントチャートの高さを調整
    adjustGanttHeight();
    
    // 日付スライダーを追加
    setupDateSlider();
    
    hideLoading();
    
    // 選択中の機材までスクロール
    if (!skipScrollToSelectedEquipment) {
      scrollToSelectedEquipment();
    }
    
    // モバイルでのスクロール同期設定
    setTimeout(() => {
      setupMobileScroll();
    }, 200);
  } catch (error) {
    console.error('ガントチャート更新エラー:', error);
    hideLoading();
    alert('ガントチャートの更新中にエラーが発生しました: ' + error);
  }
}
	
	// 2. ガントチャートの高さを調整する関数の修正
function adjustGanttHeight() {
  const ganttContainer = document.querySelector('.gantt-container');
  if (!ganttContainer) return;
  
  const ganttRows = document.querySelector('#gantt-rows');
  if (!ganttRows) return;
  
  // ガントチャートの行の数を取得
  const rowCount = ganttRows.children.length;
  
  if (rowCount === 0) {
    // 行がない場合は最小高さを設定
    ganttContainer.style.height = '100px';
  } else {
    // 「アングルパンチャー(47)」までスクロールできるように高さを固定
    // 画面の高さの60%を使用するように調整
    const viewportHeight = window.innerHeight;
    const headerHeight = document.querySelector('.header')?.offsetHeight || 0;
    const otherElementsHeight = 150; // ヘッダー、ボタン等の高さを考慮
    
    // ガントチャートの高さを設定（画面高さの60%）
    const ganttHeight = Math.max(400, viewportHeight * 0.6);
    ganttContainer.style.height = `${ganttHeight}px`;
    ganttContainer.style.overflowY = 'auto';
  }
}
  
  // 選択機材へのスクロール調整
  function scrollToSelectedEquipment() {
    // スキップフラグがオンの場合は何もしない
    if (skipScrollToSelectedEquipment) return;
    
    if (!selectedEquipmentWithLocation) return;
    
    console.log('scrollToSelectedEquipment called with:', selectedEquipmentWithLocation);
    
    // スクロール処理を遅延実行（チャートの描画完了を待つ）
    setTimeout(() => {
      try {
        const parts = selectedEquipmentWithLocation.split('|');
        const equipmentId = parts[0];
        const location = parts[1] || '';
        
        console.log('Searching for equipment:', equipmentId, 'at location:', location);
        
        // 選択した機材の行要素を検索
        let element = null;
        
        if (document.body.classList.contains('mobile-view')) {
          // モバイル表示の場合
          element = document.querySelector(`.gantt-item[data-equipment-id="${equipmentId}"][data-location="${location}"]`);
        } else {
          // PC表示の場合
          element = document.querySelector(`.gantt-row[data-equipment-id="${equipmentId}"][data-location="${location}"]`);
          
          // セレクタが見つからない場合は別の方法で検索
          if (!element) {
            console.log('Trying alternative selector');
            // 全ての行を取得してIDを比較
            const rows = document.querySelectorAll('.gantt-row');
            for (const row of rows) {
              if (row.dataset.equipmentId === equipmentId && 
                  (row.dataset.location || '') === location) {
                element = row;
                break;
              }
            }
          }
        }
        
        if (element) {
          console.log('Found element:', element);
          
          // スクロールするコンテナを取得
          const container = document.querySelector('.gantt-container');
          if (container) {
            console.log('スクロール処理を実行:');
            console.log('- 要素の位置:', element.offsetTop);
            console.log('- コンテナの位置:', container.offsetTop);
            
            // 要素を上部（少し余白を持たせて）に表示
            const scrollTop = element.offsetTop - container.offsetTop;
            container.scrollTop = scrollTop;
            
            // 確実にスクロールするため、直接コマンドも実行
            setTimeout(() => {
              // scrollIntoViewも併用
              element.scrollIntoView({block: 'start', behavior: 'auto'});
              
              // さらに遅延させて再スクロール
              setTimeout(() => {
                container.scrollTop = scrollTop;
              }, 50);
            }, 50);
            
            console.log('Scrolled to position:', scrollTop);
          } else {
            console.error('Container element not found');
          }
        } else {
          console.error('Target equipment element not found');
          console.log('Available rows:', document.querySelectorAll('.gantt-row').length);
        }
      } catch (error) {
        console.error('選択機材へのスクロールエラー:', error);
      }
    }, 800); // 遅延時間を長めに設定（800ms）
  }
  
  // createMobileLayout関数の修正部分
function createMobileLayout(days) {
  // キャッシュシステムの導入 - パフォーマンス向上のため
  if (!window.layoutCache) {
    window.layoutCache = {
      lastDays: null,
      lastEquipmentList: null
    };
  }
  
  // 入力データの変更を検出
  const daysChanged = !window.layoutCache.lastDays || 
    window.layoutCache.lastDays[0].getTime() !== days[0].getTime() ||
    window.layoutCache.lastDays[days.length - 1].getTime() !== days[days.length - 1].getTime();
  
  const equipmentChanged = !window.layoutCache.lastEquipmentList || 
    window.layoutCache.lastEquipmentList.length !== equipmentList.length;
  
  // キャッシュ更新
  window.layoutCache.lastDays = [...days];
  window.layoutCache.lastEquipmentList = [...equipmentList];
  
  // ガントチャートコンテナを取得
  const ganttContainer = document.querySelector('.gantt-container');
  if (!ganttContainer) return;
  
  // コンテナをクリア
  ganttContainer.innerHTML = '';
  
  // 日付表示エリアを追加
  const dateDisplay = document.createElement('div');
  dateDisplay.className = 'date-display-area';
  dateDisplay.textContent = `${formatDate(days[0])} 〜 ${formatDate(days[days.length - 1])}`;
  ganttContainer.appendChild(dateDisplay);
  
  // ヘッダー行の作成
  const headerRow = document.createElement('div');
  headerRow.className = 'gantt-row gantt-header';
  
  // 機材名ヘッダー
  const headerItem = document.createElement('div');
  headerItem.className = 'gantt-item';
  headerItem.textContent = '機材名';
  headerItem.style.zIndex = '30'; // 最前面に固定
  headerRow.appendChild(headerItem);
  
  // 日付ヘッダー（スクロール可能部分）
  const dateHeaders = document.createElement('div');
  dateHeaders.className = 'gantt-dates';
  dateHeaders.id = 'date-headers';
  
  // 日付ヘッダーに日付を追加
  const dateFragment = document.createDocumentFragment();
  days.forEach(day => {
    const header = document.createElement('div');
    header.className = 'gantt-date';
    header.textContent = formatDate(day, 'MM/dd');
    dateFragment.appendChild(header);
  });
  dateHeaders.appendChild(dateFragment);
  
  // 日付ヘッダーをヘッダー行に追加
  headerRow.appendChild(dateHeaders);
  ganttContainer.appendChild(headerRow);
  
  // 行コンテナ作成
  const rowsContainer = document.createElement('div');
  rowsContainer.id = 'gantt-rows';
  ganttContainer.appendChild(rowsContainer);
  
  // 選択中の機器+定置場所の情報を取得
  let selectedPlaceInfo = null;
  if (selectedEquipmentWithLocation) {
    const parts = selectedEquipmentWithLocation.split('|');
    if (parts.length > 1) {
      selectedPlaceInfo = {
        id: parts[0],
        location: parts[1] || ''
      };
    }
  }
  
  // 機材をあいうえお順に並べ替え
  const sortedEquipmentList = [...equipmentList]
    .filter(item => (parseInt(item['総台数']) || 0) > 0) // 台数が0の場合は表示しない
    .sort((a, b) => {
      if (!a['機器名称']) return 1;
      if (!b['機器名称']) return -1;
      return String(a['機器名称']).localeCompare(String(b['機器名称']), 'ja');
    });

  // すべての機材を表示対象とする
  const displayEquipment = sortedEquipmentList;
  
  // 表示対象が存在しない場合
  if (displayEquipment.length === 0) {
    const emptyRow = document.createElement('div');
    emptyRow.className = 'gantt-row';
    emptyRow.style.height = '100px';
    
    const emptyMessage = document.createElement('div');
    emptyMessage.className = 'gantt-item center-align';
    emptyMessage.style.width = '100%';
    emptyMessage.style.padding = '20px';
    emptyMessage.style.color = '#666';
    emptyMessage.textContent = '表示する機材がありません。機材マスターから機材を追加してください。';
    
    emptyRow.appendChild(emptyMessage);
    rowsContainer.appendChild(emptyRow);
    return;
  }
  
  // 各機材の行を作成
  displayEquipment.forEach(item => {
    if (!item['機器管理番号']) return;
    
    const equipmentId = item['機器管理番号'];
    const location = item['定置場所'] || '';
    
    // 行作成
    const row = document.createElement('div');
    row.className = 'gantt-row';
    row.dataset.equipmentId = equipmentId;
    row.dataset.location = location;
    row.style.borderBottom = '1px solid #e0e0e0';
    
    // 現在選択中の機器+定置場所かどうかチェック
    const isSelected = selectedPlaceInfo && 
                    String(equipmentId) === String(selectedPlaceInfo.id) && 
                    String(location) === String(selectedPlaceInfo.location);
    
    if (isSelected) {
      row.classList.add('selected-equipment');
    }
    
    // 機材名セル
    const nameCell = document.createElement('div');
    nameCell.className = 'gantt-item';
    nameCell.dataset.equipmentId = equipmentId;
    nameCell.dataset.location = location;
    nameCell.style.position = 'sticky';
    nameCell.style.left = '0';
    nameCell.style.zIndex = '20';
    
    if (isSelected) {
      nameCell.style.backgroundColor = '#e3f2fd';
    }

    const infoContainer = document.createElement('div');
    infoContainer.className = 'equipment-info';

    // 機材名と機器管理番号
    const nameDiv = document.createElement('div');
    nameDiv.className = 'equipment-name';
    nameDiv.textContent = `${item['機器名称']} (${equipmentId})`;
    infoContainer.appendChild(nameDiv);
    
    // 定置場所
    if (item['定置場所']) {
      const locationDiv = document.createElement('div');
      locationDiv.className = 'equipment-location';
      locationDiv.textContent = `${item['定置場所']}`;
      infoContainer.appendChild(locationDiv);
    }
    
    // 在庫台数
    const stockDiv = document.createElement('div');
    stockDiv.className = 'equipment-stock';
    stockDiv.textContent = `在庫台数: ${item['総台数'] || 0}台`;
    infoContainer.appendChild(stockDiv);
    
    nameCell.appendChild(infoContainer);
    row.appendChild(nameCell);
    
    // タイムライン作成
    const timeline = document.createElement('div');
    timeline.className = 'gantt-timeline';
    timeline.dataset.equipment = equipmentId;
    timeline.dataset.location = location;
    timeline.style.display = 'flex';
    timeline.style.position = 'relative';
    timeline.style.flex = '1';
    
    // マウスダウンイベント設定
    timeline.addEventListener('mousedown', onTimelineMouseDown);
    timeline.addEventListener('touchstart', function(e) {
      // タッチイベントを通過させる（スワイプ処理用）
    }, { passive: true });
    
    // 日付セル作成
    days.forEach((day, index) => {
      const dayCell = document.createElement('div');
      dayCell.className = 'gantt-day';
      dayCell.dataset.date = formatDate(day);
      dayCell.dataset.equipment = equipmentId;
      dayCell.dataset.location = location;
      dayCell.dataset.index = index;
      timeline.appendChild(dayCell);
    });
    
    // 機器と定置場所が一致する貸出だけを表示
    const myRentals = rentalData.filter(rental => {
      if (!rental) return false;
      
      const rentalEquipId = String(rental['機器管理番号'] || '');
      const targetEquipId = String(equipmentId || '');
      const equipMatch = (rentalEquipId === targetEquipId);
      
      const rentalLocation = String(rental['貸出元'] || '');
      const targetLocation = String(location || '');
      const locationMatch = (rentalLocation === targetLocation);
      
      const isActive = rental['ステータス'] !== '返却済み' || !rental['返却日'];
      
      return equipMatch && locationMatch && isActive;
    });
    
    // 貸出が複数ある場合に重ならないように処理する
    if (myRentals.length > 0) {
      // 貸出を日付範囲に変換
      const rentalRanges = myRentals.map(rental => {
        let startDay = parseDate(rental['借用開始日']);
        let endDay = parseDate(rental['借用終了日']);
        
        if (!startDay || !endDay) return null;
        
        startDay.setHours(0, 0, 0, 0);
        endDay.setHours(0, 0, 0, 0);
        
        return {
          rental: rental,
          startDay: startDay,
          endDay: endDay,
          layer: null
        };
      }).filter(range => range !== null);
      
      // 表示範囲を考慮
      const rangeStart = new Date(days[0]);
      const rangeEnd = new Date(days[days.length - 1]);
      rangeStart.setHours(0, 0, 0, 0);
      rangeEnd.setHours(23, 59, 59, 999);
      
      // 貸出を日付順にソート
      rentalRanges.sort((a, b) => a.startDay.getTime() - b.startDay.getTime());
      
      // 各貸出に表示レイヤーを割り当て
      const layers = [];
      
      // 各貸出に対してレイヤーを割り当てる
      rentalRanges.forEach(rentalRange => {
        let assignedLayer = false;
        
        for (let i = 0; i < layers.length; i++) {
          let hasConflict = false;
          
          for (const existingRange of layers[i]) {
            if (!(rentalRange.endDay < existingRange.startDay || 
                 rentalRange.startDay > existingRange.endDay)) {
              hasConflict = true;
              break;
            }
          }
          
          if (!hasConflict) {
            layers[i].push(rentalRange);
            rentalRange.layer = i;
            assignedLayer = true;
            break;
          }
        }
        
        if (!assignedLayer) {
          layers.push([rentalRange]);
          rentalRange.layer = layers.length - 1;
        }
      });
      
      // レイヤー数に基づいて行の高さを調整（最低2つのレイヤーを確保）
      const layerCount = Math.max(2, layers.length);
      row.style.height = (layerCount * 40 + 20) + 'px';
      timeline.style.height = (layerCount * 40 + 20) + 'px';
      
      // ここで事前にcellWidth変数を定義
      const cellWidth = document.body.classList.contains('mobile-view') ? 
                      (userSettings.mobileCellWidth || 80) : 
                      (userSettings.cellWidth || 80);
      
      // 各貸出バーを作成
      rentalRanges.forEach(rentalRange => {
        try {
          const rental = rentalRange.rental;
          const startDay = rentalRange.startDay;
          const endDay = rentalRange.endDay;
          const layer = rentalRange.layer;
          
          // 範囲外なら表示しない
          if (endDay < rangeStart || startDay > rangeEnd) return;
          
          // バーの日付範囲
          let visibleStartDay = startDay < rangeStart ? rangeStart : startDay;
          let visibleEndDay = endDay > rangeEnd ? rangeEnd : endDay;
          
          // インデックスを計算
          let startIdx = -1;
          let endIdx = -1;
          
          for (let i = 0; i < days.length; i++) {
            const currentDay = new Date(days[i]);
            currentDay.setHours(0, 0, 0, 0);
            
            if (startIdx === -1 && visibleStartDay.getTime() <= currentDay.getTime()) {
              startIdx = i;
            }
            
            if (visibleEndDay.getTime() >= currentDay.getTime()) {
              endIdx = i;
            }
          }
          
          // インデックスチェック
          if (startIdx === -1 || endIdx === -1 || startIdx > endIdx) return;
          
          const width = ((endIdx - startIdx) + 1) * cellWidth;
          const left = startIdx * cellWidth;
          const top = layer * 40 + 10; // 10pxの余白を追加
          
          // バー要素作成
          const bar = document.createElement('div');
          bar.className = 'rental-bar';
          bar.style.position = 'absolute';
          bar.style.left = left + 'px';
          bar.style.top = top + 'px';
          bar.style.width = width + 'px';
          bar.style.height = '40px';
          bar.style.borderRadius = '3px';
          bar.style.color = 'white';
          bar.style.padding = '5px 30px 5px 5px';
          bar.style.fontSize = '16px';
          bar.style.zIndex = '15';
          bar.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
          bar.style.overflow = 'hidden';
          bar.style.textOverflow = 'ellipsis';
          bar.style.whiteSpace = 'nowrap';
          bar.style.display = 'flex';
          bar.style.alignItems = 'center';

          // 元の位置情報を保存
          bar.dataset.originalLeft = left;
          bar.dataset.originalWidth = width;
          bar.dataset.startIdx = startIdx;
          bar.dataset.endIdx = endIdx;
          bar.dataset.startDate = formatDate(startDay);
          bar.dataset.endDate = formatDate(endDay);

          // バーデータとテキスト
          bar.dataset.rentalId = rental['登録日時'] ? rental['登録日時'].toString() : '';
          bar.dataset.layer = layer;
          bar.dataset.location = location;

          bar.textContent = `${rental['数量']}台-${rental['使用場所']}(${getUserDisplayName(rental['借用者'])})`;
          
          // 定置場所と使用場所に基づいて色を決定
          if (location && rental['使用場所'] && location === rental['使用場所']) {
            // 同じ場所の場合は緑色
            bar.style.backgroundColor = '#26a69a';
          } else {
            // 異なる場所の場合はオレンジ色
            bar.style.backgroundColor = '#ff9800';
          }

          // 返却ボタンを追加
          const returnButton = document.createElement('button');
          returnButton.className = 'btn-floating btn-small return-button';
          returnButton.innerHTML = '<i class="material-icons">reply</i>';
          returnButton.style.position = 'absolute';
          returnButton.style.right = '5px';
          returnButton.style.top = '50%';
          returnButton.style.transform = 'translateY(-50%)';
          returnButton.title = '返却';
          
          // 返却ボタンクリックイベント
          returnButton.addEventListener('click', function(e) {
            e.stopPropagation(); // バブリングを防止
            showReturnModal(rental);
          });
          
          bar.appendChild(returnButton);

          // バークリックイベント
          bar.addEventListener('click', function(e) {
            // スワイプ操作中またはスワイプ直後は無視
            if (isSwiping || (Date.now() - swipeEndTime < userSettings.swipeDelay)) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            showReturnModal(rental);
          });

          // タイムラインに追加
          timeline.appendChild(bar);
        } catch (error) {
          console.error('貸出バー作成エラー:', error);
        }
      });
    }
    
    row.appendChild(timeline);
    rowsContainer.appendChild(row);
  });
  
  // 行コンテナにスクロールイベントを設定
  rowsContainer.addEventListener('scroll', function() {
    // 縦スクロール位置を保存
    savedScrollPosition.top = this.scrollTop;
  });
  
  // 日付ヘッダーにスクロールイベントを設定
  dateHeaders.addEventListener('scroll', function() {
    // 全タイムラインのスクロール位置を同期
    const dateHeadersScrollLeft = this.scrollLeft;
    document.querySelectorAll('.gantt-timeline').forEach(timeline => {
      timeline.scrollLeft = dateHeadersScrollLeft;
    });
    
    // 横スクロール位置を保存
    savedScrollPosition.left = dateHeadersScrollLeft;
  });
  
  // 日付スライダーを追加
  setupDateSlider();
  
  // モバイル用のスクロール同期を設定
  setTimeout(() => {
    setupMobileScroll();
  }, 200);
}
  
  // createDesktopLayout関数の完全なコード
function createDesktopLayout(days) {
  // ガントチャートコンテナを取得
  const ganttContainer = document.querySelector('.gantt-container');
  if (!ganttContainer) return;
  
  // コンテナをクリア
  ganttContainer.innerHTML = '';
  
  // 日付ヘッダー行
  const headerRow = document.createElement('div');
  headerRow.className = 'gantt-row gantt-header';
  
  // 機材名ヘッダー
  const headerItem = document.createElement('div');
  headerItem.className = 'gantt-item';
  headerItem.textContent = '機材名';
  headerRow.appendChild(headerItem);
  
  // 日付ヘッダー
  const dateHeaders = document.createElement('div');
  dateHeaders.className = 'gantt-dates';
  dateHeaders.id = 'date-headers';
  dateHeaders.style.overflowX = 'auto'; // 横スクロール可能に
  
  // 日付ヘッダーに日付を追加
  days.forEach(day => {
    const header = document.createElement('div');
    header.className = 'gantt-date';
    header.textContent = formatDate(day, 'MM/dd');
    dateHeaders.appendChild(header);
  });
  
  // 日付ヘッダーにスクロールイベントリスナーを追加（同期スクロール用）
  dateHeaders.addEventListener('scroll', function() {
    const timelines = document.querySelectorAll('.gantt-timeline');
    timelines.forEach(timeline => {
      timeline.scrollLeft = dateHeaders.scrollLeft;
    });
    
    // スライダーとも同期
    const slider = document.getElementById('date-slider');
    if (slider) {
      const scrollWidth = dateHeaders.scrollWidth - dateHeaders.clientWidth;
      if (scrollWidth > 0) {
        slider.value = (dateHeaders.scrollLeft / scrollWidth) * 100;
      }
    }
  });
  
  headerRow.appendChild(dateHeaders);
  ganttContainer.appendChild(headerRow);
  
  // 行コンテナ
  const ganttRows = document.createElement('div');
  ganttRows.id = 'gantt-rows';
  ganttRows.style.overflowY = 'auto'; // 縦スクロール可能に
  ganttContainer.appendChild(ganttRows);
  
  // 選択中の機器+定置場所の情報を取得
  let selectedPlaceInfo = null;
  if (selectedEquipmentWithLocation) {
    const parts = selectedEquipmentWithLocation.split('|');
    if (parts.length > 1) {
      selectedPlaceInfo = {
        id: parts[0],
        location: parts[1] || ''
      };
    }
  }
  
  // 機材をあいうえお順に並べ替え
  const sortedEquipmentList = [...equipmentList]
    .filter(item => (parseInt(item['総台数']) || 0) > 0) // 台数が0の場合は表示しない
    .sort((a, b) => {
      if (!a['機器名称']) return 1;
      if (!b['機器名称']) return -1;
      return String(a['機器名称']).localeCompare(String(b['機器名称']), 'ja');
    });

  // すべての機材を表示対象とする
  const displayEquipment = sortedEquipmentList;
  
  // 表示対象が存在しない場合
  if (displayEquipment.length === 0) {
    const emptyRow = document.createElement('div');
    emptyRow.className = 'gantt-row';
    emptyRow.style.height = '100px';
    
    const emptyMessage = document.createElement('div');
    emptyMessage.className = 'gantt-item center-align';
    emptyMessage.style.width = '100%';
    emptyMessage.style.padding = '20px';
    emptyMessage.style.color = '#666';
    emptyMessage.textContent = '表示する機材がありません。機材マスターから機材を追加してください。';
    
    emptyRow.appendChild(emptyMessage);
    ganttRows.appendChild(emptyRow);
    
    return;
  }
  
  // 各機材の行を作成
  displayEquipment.forEach(item => {
    if (!item['機器管理番号']) return;
    
    const equipmentId = item['機器管理番号'];
    const location = item['定置場所'] || '';
    
    // 行作成
    const row = document.createElement('div');
    row.className = 'gantt-row';
    row.dataset.equipmentId = equipmentId;
    row.dataset.location = location;
    
    // 現在選択中の機器+定置場所かどうかチェック
    const isSelected = selectedPlaceInfo && 
                      String(equipmentId) === String(selectedPlaceInfo.id) && 
                      String(location) === String(selectedPlaceInfo.location);
    
    if (isSelected) {
      row.classList.add('selected-equipment');
    }
    
    // 機材名セル
    const nameCell = document.createElement('div');
    nameCell.className = 'gantt-item';

    const infoContainer = document.createElement('div');
    infoContainer.className = 'equipment-info';

    // 機材名と機器管理番号
    const nameDiv = document.createElement('div');
    nameDiv.className = 'equipment-name';
    nameDiv.textContent = `${item['機器名称']} (${equipmentId})`;
    infoContainer.appendChild(nameDiv);
    
    // 定置場所
    if (item['定置場所']) {
      const locationDiv = document.createElement('div');
      locationDiv.className = 'equipment-location';
      locationDiv.textContent = `${item['定置場所']}`;
      infoContainer.appendChild(locationDiv);
    }
    
    // 在庫台数
    const stockDiv = document.createElement('div');
    stockDiv.className = 'equipment-stock';
    stockDiv.textContent = `在庫台数: ${item['総台数'] || 0}台`;
    infoContainer.appendChild(stockDiv);
    
    // 追加情報: 仕様
    if (item['仕様']) {
      addDetailLine(infoContainer, '仕様', item['仕様']);
    }
    
    // 追加情報: 型番
    if (item['型番']) {
      addDetailLine(infoContainer, '型番', item['型番']);
    }
    
    // 追加情報: メーカー
    if (item['メーカー']) {
      addDetailLine(infoContainer, 'メーカー', item['メーカー']);
    }
    
    // 追加情報: 備考1
    if (item['備考1']) {
      addDetailLine(infoContainer, '備考1', item['備考1']);
    }
    
    // 追加情報: 備考2
    if (item['備考2']) {
      addDetailLine(infoContainer, '備考2', item['備考2']);
    }
    
    nameCell.appendChild(infoContainer);

    if (isSelected) {
      nameCell.style.backgroundColor = '#e3f2fd';
    }

    row.appendChild(nameCell);
    
    // タイムライン作成
    const timeline = document.createElement('div');
    timeline.className = 'gantt-timeline';
    timeline.style.position = 'relative';
    timeline.style.flex = '1';
    timeline.dataset.equipment = equipmentId;
    timeline.dataset.location = location;
    
    // 横スクロールバーを表示しない（スクロールは親要素と同期）
    timeline.style.overflowX = 'hidden';
    
    // マウスホイールを無効化してスクロール同期を維持
    timeline.addEventListener('wheel', function(e) {
      if (e.shiftKey) {
        e.preventDefault();
        const dateHeaders = document.querySelector('#date-headers');
        if (dateHeaders) {
          dateHeaders.scrollLeft += e.deltaY;
        }
      }
    });
    
    // マウスダウンイベント設定
    timeline.addEventListener('mousedown', onTimelineMouseDown);
    
    // 日付セル作成
    days.forEach((day, index) => {
      const dayCell = document.createElement('div');
      dayCell.className = 'gantt-day';
      dayCell.dataset.date = formatDate(day);
      dayCell.dataset.equipment = equipmentId;
      dayCell.dataset.location = location;
      dayCell.dataset.index = index;
      timeline.appendChild(dayCell);
    });
    
    // 機器と定置場所が一致する貸出だけを表示
    const myRentals = rentalData.filter(rental => {
      if (!rental) return false;
      
      const rentalEquipId = String(rental['機器管理番号'] || '');
      const targetEquipId = String(equipmentId || '');
      const equipMatch = (rentalEquipId === targetEquipId);
      
      const rentalLocation = String(rental['貸出元'] || '');
      const targetLocation = String(location || '');
      const locationMatch = (rentalLocation === targetLocation);
      
      const isActive = rental['ステータス'] !== '返却済み' || !rental['返却日'];
      
      return equipMatch && locationMatch && isActive;
    });
    
    // 貸出が複数ある場合に重ならないように処理する
    if (myRentals.length > 0) {
      // 貸出を日付範囲に変換
      const rentalRanges = myRentals.map(rental => {
        let startDay = parseDate(rental['借用開始日']);
        let endDay = parseDate(rental['借用終了日']);
        
        if (!startDay || !endDay) return null;
        
        startDay.setHours(0, 0, 0, 0);
        endDay.setHours(0, 0, 0, 0);
        
        return {
          rental: rental,
          startDay: startDay,
          endDay: endDay,
          layer: null
        };
      }).filter(range => range !== null);
      
      // 表示範囲を考慮
      const rangeStart = new Date(days[0]);
      const rangeEnd = new Date(days[days.length - 1]);
      rangeStart.setHours(0, 0, 0, 0);
      rangeEnd.setHours(23, 59, 59, 999);
      
      // 貸出を日付順にソート
      rentalRanges.sort((a, b) => a.startDay.getTime() - b.startDay.getTime());
      
      // 各貸出に表示レイヤーを割り当て
      const layers = [];
      
      // 各貸出に対してレイヤーを割り当てる
      rentalRanges.forEach(rentalRange => {
        let assignedLayer = false;
        
        for (let i = 0; i < layers.length; i++) {
          let hasConflict = false;
          
          for (const existingRange of layers[i]) {
            if (!(rentalRange.endDay < existingRange.startDay || 
                 rentalRange.startDay > existingRange.endDay)) {
              hasConflict = true;
              break;
            }
          }
          
          if (!hasConflict) {
            layers[i].push(rentalRange);
            rentalRange.layer = i;
            assignedLayer = true;
            break;
          }
        }
        
        if (!assignedLayer) {
          layers.push([rentalRange]);
          rentalRange.layer = layers.length - 1;
        }
      });
      
      // レイヤー数に基づいて行の高さを調整（最低2つのレイヤーを確保）
      const layerCount = Math.max(2, layers.length);
      row.style.height = (layerCount * 40) + 'px';
      timeline.style.height = (layerCount * 40) + 'px';
      
      // 各貸出バーを作成
      rentalRanges.forEach(rentalRange => {
        try {
          const rental = rentalRange.rental;
          const startDay = rentalRange.startDay;
          const endDay = rentalRange.endDay;
          const layer = rentalRange.layer;
          
          // 範囲外なら表示しない
          if (endDay < rangeStart || startDay > rangeEnd) return;
          
          // バーの日付範囲
          let visibleStartDay = startDay < rangeStart ? rangeStart : startDay;
          let visibleEndDay = endDay > rangeEnd ? rangeEnd : endDay;
          
          // インデックスを計算
          let startIdx = -1;
          let endIdx = -1;
          
          for (let i = 0; i < days.length; i++) {
            const currentDay = new Date(days[i]);
            currentDay.setHours(0, 0, 0, 0);
            
            if (startIdx === -1 && visibleStartDay.getTime() <= currentDay.getTime()) {
              startIdx = i;
            }
            
            if (visibleEndDay.getTime() >= currentDay.getTime()) {
              endIdx = i;
            }
          }
          
          // インデックスチェック
          if (startIdx === -1 || endIdx === -1 || startIdx > endIdx) return;
          
          // セル幅を取得（モバイルかPCかで異なる）
          const cellWidth = document.body.classList.contains('mobile-view') ? 
                          (userSettings.mobileCellWidth || 80) : 
                          (userSettings.cellWidth || 80);
          
          const width = ((endIdx - startIdx) + 1) * cellWidth;
          const left = startIdx * cellWidth;
          const top = layer * 40;
          
          // バー要素作成
          const bar = document.createElement('div');
          bar.className = 'rental-bar';
          bar.style.position = 'absolute';
          bar.style.left = left + 'px';
          bar.style.top = top + 'px';
          bar.style.width = width + 'px';
          bar.style.height = '30px';
          bar.style.borderRadius = '3px';
          bar.style.color = 'white';
          bar.style.padding = '5px 30px 5px 5px';
          bar.style.fontSize = '12px';
          bar.style.zIndex = '10';
          bar.style.cursor = 'pointer';
          bar.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
          bar.style.overflow = 'hidden';
          bar.style.textOverflow = 'ellipsis';
          bar.style.whiteSpace = 'nowrap';

          // バーデータとテキスト
          bar.dataset.rentalId = rental['登録日時'] ? rental['登録日時'].toString() : '';
          bar.dataset.layer = layer;
          bar.dataset.location = location;

          bar.textContent = `${rental['数量']}台-${rental['使用場所']}(${getUserDisplayName(rental['借用者'])})`;
          
          // 定置場所と使用場所に基づいて色を決定
          if (location && rental['使用場所'] && location === rental['使用場所']) {
            // 同じ場所の場合は緑色
            bar.style.backgroundColor = '#26a69a';
          } else {
            // 異なる場所の場合はオレンジ色
            bar.style.backgroundColor = '#ff9800';
          }

          // ドラッグ＆リサイズ機能を有効化
          enableBarDragAndResize(bar, rental);

          // タイムラインに追加
          timeline.appendChild(bar);
        } catch (error) {
          console.error('貸出バー作成エラー:', error);
        }
      });
    }
    
    row.appendChild(timeline);
    ganttRows.appendChild(row);
  });
}
  
  // 現在の選択状態を保存
  function saveCurrentSelection() {
    if (selectedEquipmentWithLocation) {
      localStorage.setItem('lastSelectedEquipment', selectedEquipmentWithLocation);
    }
  }

  // 前回の選択状態を復元
  function restoreLastSelection() {
    const lastSelected = localStorage.getItem('lastSelectedEquipment');
    
    if (lastSelected) {
      // セレクトボックスの値を設定
      const selectBox = document.getElementById('equipment-select');
      if (selectBox) {
        // オプションが存在するか確認
        const options = Array.from(selectBox.options);
        const found = options.some(option => option.value === lastSelected);
        
        if (found) {
          selectBox.value = lastSelected;
          selectedEquipmentWithLocation = lastSelected;
          
          // 機器管理番号を取得
          const parts = lastSelected.split('|');
          selectedEquipment = parts[0];
          
          // Materializeのセレクトを更新
          try {
            M.FormSelect.init(selectBox);
          } catch (e) {
            console.error('セレクト初期化エラー:', e);
          }
        } else {
          // 前回の選択が見つからない場合は、機材名順で最初の機材を選択
          selectFirstEquipmentByName();
        }
      }
    } else {
      // localStorage に記録がない場合は、機材名順で最初の機材を選択
      selectFirstEquipmentByName();
    }
  }
  
  // 機材名順で最初の機材を選択する関数
  function selectFirstEquipmentByName() {
    if (equipmentList.length === 0) return;
    
    // 機材を機材名でソート
    const sortedEquipment = [...equipmentList].sort((a, b) => {
      if (!a['機器名称']) return 1;
      if (!b['機器名称']) return -1;
      return String(a['機器名称']).localeCompare(String(b['機器名称']), 'ja');
    });
    
    // 最初の機材を選択
    const firstEquipment = sortedEquipment[0];
    if (firstEquipment && firstEquipment['機器管理番号']) {
      selectedEquipment = firstEquipment['機器管理番号'];
      selectedEquipmentWithLocation = `${firstEquipment['機器管理番号']}|${firstEquipment['定置場所'] || ''}`;
      
      // セレクトボックスの値も更新
      const selectBox = document.getElementById('equipment-select');
      if (selectBox) {
        selectBox.value = selectedEquipmentWithLocation;
        // Materializeのセレクトを更新
        try {
          M.FormSelect.init(selectBox);
        } catch (e) {
          console.error('セレクト初期化エラー:', e);
        }
      }
    }
  }

  // 日付パース関数（文字列またはDate型からDateオブジェクトを返す）
  function parseDate(dateInput) {
    if (!dateInput) return null;
    
    // すでにDateオブジェクトなら変換不要
    if (dateInput instanceof Date) {
      return new Date(dateInput);
    }
    
    // 文字列の場合
    if (typeof dateInput === 'string') {
      // yyyy-MM-dd または yyyy/MM/dd 形式を想定
      const date = new Date(dateInput);
      if (!isNaN(date.getTime())) {
        return date;
      }
      
      // フォーマットを明示的に処理
      const parts = dateInput.split(/[-\/]/);
      if (parts.length === 3) {
        // 年月日の順番を判断
        let year, month, day;
        
        if (parts[0].length === 4) {
          // yyyy-MM-dd形式
          year = parseInt(parts[0]);
          month = parseInt(parts[1]) - 1; // 月は0始まり
          day = parseInt(parts[2]);
        } else {
          // MM/dd/yyyy形式かもしれない
          month = parseInt(parts[0]) - 1;
          day = parseInt(parts[1]);
          year = parseInt(parts[2]);
        }
        
        const newDate = new Date(year, month, day);
        if (!isNaN(newDate.getTime())) {
          return newDate;
        }
      }
    }
    
    console.warn('不正な日付形式:', dateInput);
    return null;
  }
  
  // タイムラインドラッグ処理
  function onTimelineMouseDown(e) {
    // レンタルバーなら無視
    if (e.target.classList.contains('rental-bar') || e.target.closest('.rental-bar')) return;
    
    // 右クリックは無視
    if (e.button !== 0) return;
    
    e.preventDefault();
    e.stopPropagation(); // イベント伝播を止める
    
    // クリックした要素がタイムラインかセルか
    let targetCell = e.target;
    const timeline = e.currentTarget;
    
    // ドラッグされた列の機器管理番号と定置場所を取得
    const timelineEquipmentId = timeline.dataset.equipment;
    const timelineLocation = timeline.dataset.location || '';
    
    if (!timelineEquipmentId) {
      console.error('タイムラインに機器管理番号情報がありません');
      return;
    }
    
    // タイムラインをクリックした場合は近いセルを特定
    if (!targetCell.classList.contains('gantt-day')) {
      const cells = Array.from(timeline.querySelectorAll('.gantt-day'));
      if (cells.length === 0) return;
      
      // セル幅を取得（モバイルかPCかで異なる）
      const cellWidth = document.body.classList.contains('mobile-view') ? 
                      (userSettings.mobileCellWidth || 80) : 
                      (userSettings.cellWidth || 80);
      
      const timelineRect = timeline.getBoundingClientRect();
      const x = Math.max(0, e.clientX - timelineRect.left);
      const cellIndex = Math.floor(x / cellWidth);
      
      if (cellIndex >= 0 && cellIndex < cells.length) {
        targetCell = cells[cellIndex];
      } else {
        return;
      }
    }
    
    // セルから日付情報取得
    const startDate = targetCell.dataset.date;
    
    if (!startDate) {
      console.error('セルのデータ属性がありません', targetCell);
      return;
    }
    
    // ドラッグ開始
    isDragging = true;
    dragStartCell = targetCell;
    
    // ハイライト表示
    targetCell.classList.add('drag-highlight');
    
    // 全セル取得
    const cells = Array.from(timeline.querySelectorAll('.gantt-day'));
    const startIndex = cells.indexOf(targetCell);
    
    console.log(`ドラッグ開始: セル${startIndex}, 日付=${startDate}, 機器=${timelineEquipmentId}, 定置場所=${timelineLocation}`);
    
    // マウス移動イベント
    function onMouseMove(moveEvent) {
      moveEvent.preventDefault();
      if (!isDragging) return;
      
      // マウス位置を計算
      const rect = timeline.getBoundingClientRect();
      const x = Math.max(0, Math.min(moveEvent.clientX - rect.left, rect.width));
      
      // セル幅を取得（モバイルかPCかで異なる）
      const cellWidth = document.body.classList.contains('mobile-view') ? 
                      (userSettings.mobileCellWidth || 80) : 
                      (userSettings.cellWidth || 80);
      
      const cellIndex = Math.min(Math.max(0, Math.floor(x / cellWidth)), cells.length - 1);
      
      // ハイライトクリア
      cells.forEach(cell => cell.classList.remove('drag-highlight'));
      
      // 範囲ハイライト
      const minIdx = Math.min(startIndex, cellIndex);
      const maxIdx = Math.max(startIndex, cellIndex);
      
      for (let i = minIdx; i <= maxIdx; i++) {
        cells[i].classList.add('drag-highlight');
      }
    }
    
    // マウスアップイベント
    function onMouseUp(upEvent) {
      upEvent.preventDefault();
      
      // イベント削除
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      
      if (!isDragging) return;
      
      // マウス位置を計算
      const rect = timeline.getBoundingClientRect();
      const x = Math.max(0, Math.min(upEvent.clientX - rect.left, rect.width));
      
      // セル幅を取得（モバイルかPCかで異なる）
      const cellWidth = document.body.classList.contains('mobile-view') ? 
                      (userSettings.mobileCellWidth || 80) : 
                      (userSettings.cellWidth || 80);
      
      const cellIndex = Math.min(Math.max(0, Math.floor(x / cellWidth)), cells.length - 1);
      
      // 選択範囲の日付を取得
      const minIdx = Math.min(startIndex, cellIndex);
      const maxIdx = Math.max(startIndex, cellIndex);
      
      const fromDate = cells[minIdx].dataset.date;
      const toDate = cells[maxIdx].dataset.date;
      
      console.log(`ドラッグ終了: 開始=${fromDate}, 終了=${toDate}, 機器=${timelineEquipmentId}, 定置場所=${timelineLocation}`);
      
      // ハイライトクリア
      cells.forEach(cell => cell.classList.remove('drag-highlight'));
      
      // ドラッグリセット
      isDragging = false;
      dragStartCell = null;
      
      // 貸出モーダル表示 - ドラッグした列の機器情報を渡す
      showRentalModal(timelineEquipmentId, fromDate, toDate, timelineLocation);
    }
    
    // イベント追加
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  }

  // 貸出モーダル表示の修正
	function showRentalModal(equipmentId, startDateStr, endDateStr, location) {
  try {
    console.log('貸出モーダル表示:', equipmentId, startDateStr, endDateStr, '定置場所:', location);
    
    // スワイプ操作直後は貸出モーダルを表示しない
    if (isSwiping || (Date.now() - swipeEndTime < userSettings.swipeDelay)) {
      console.log('スワイプ操作直後のため貸出モーダル表示をスキップします');
      return;
    }
    
    // 既に開いているモーダルをすべて閉じる
    closeAllModals();
    
    // ドラッグされた列の機器と定置場所の情報を取得
    let equipment = null;
    
    // 指定された機器ID + 定置場所で機材を検索
    equipment = equipmentList.find(item => 
      String(item['機器管理番号']) === String(equipmentId) && 
      String(item['定置場所'] || '') === String(location || '')
    );
    
    // 見つからなければ機器IDだけで検索
    if (!equipment) {
      equipment = equipmentList.find(item => 
        String(item['機器管理番号']) === String(equipmentId)
      );
    }
    
    if (!equipment) {
      alert(`機材情報の取得に失敗しました。\n機器管理番号: ${equipmentId}\n定置場所: ${location || '未設定'}`);
      return;
    }
    
    // モーダル要素の取得
    const modal = document.getElementById('rental-modal');
    if (!modal) {
      alert('モーダル要素が見つかりません');
      return;
    }
    
    // フォーム要素の取得
    const equipmentField = document.getElementById('rental-equipment');
    const startDateField = document.getElementById('rental-start');
    const endDateField = document.getElementById('rental-end');
    const quantityField = document.getElementById('rental-quantity');
    const projectSelect = document.getElementById('rental-project');
    const newProjectField = document.getElementById('new-project');
    const sourceLocationField = document.getElementById('rental-source-location');
    
    if (!equipmentField || !startDateField || !endDateField || !quantityField || 
        !projectSelect || !newProjectField || !sourceLocationField) {
      alert('フォーム要素が見つかりません');
      return;
    }
    
    // 機材名称の設定 - 機材名と管理番号を表示
    equipmentField.value = `${equipment['機器名称']} (${equipment['機器管理番号']})`;
    
    // 借用開始日と終了日の設定
    startDateField.value = startDateStr;
    endDateField.value = endDateStr;
    
    // 数量の初期値を1に設定
    quantityField.value = 1;
    
    // 新しい現場名入力欄をクリア（追加）
    newProjectField.value = '';
    
    // 貸出元（定置場所）の設定
    sourceLocationField.value = location || '';
    
    // 現場マスターのリストをドロップダウンに設定
    projectSelect.innerHTML = '<option value="" disabled selected>現場を選択</option>';
    if (projectsList && projectsList.length > 0) {
      // 現場をあいうえお順にソート
      const sortedProjects = [...projectsList].sort((a, b) => 
        String(a.name || '').localeCompare(String(b.name || ''), 'ja')
      );
      
      // 選択肢を追加
      sortedProjects.forEach(project => {
        if (!project.name) return;
        
        const option = document.createElement('option');
        option.value = project.name;
        option.textContent = project.name;
        projectSelect.appendChild(option);
      });
    }
    
    // ラベルを浮かせる（Materialize CSS）
    M.updateTextFields();
    
    // モーダル表示
    const instance = M.Modal.getInstance(modal);
    if (instance) {
      instance.open();
    } else {
      const modalOptions = {
        dismissible: true,
        opacity: 0.5,
        inDuration: 300,
        outDuration: 200,
        preventScrolling: true
      };
      M.Modal.init(modal, modalOptions).open();
    }
  } catch (error) {
    console.error('貸出モーダル表示エラー:', error);
    alert('貸出モーダル表示中にエラーが発生しました: ' + error);
  }
  // モーダル表示後に日付ピッカーを初期化
  setTimeout(() => {
    setupDatePickers();
  }, 100);
  // モーダル表示後に数量コントロールを設定
  setTimeout(() => {
    setupQuantityControls();
  }, 100);
}
  
  // 返却モーダル表示の修正
	function showReturnModal(rental) {
	  try {
	    console.log('返却モーダル表示:', rental['機器管理番号'], 'Rental ID:', rental['登録日時']?.toString());
	    
	    // スワイプ操作直後は返却モーダルを表示しない
	    if (isSwiping || (Date.now() - swipeEndTime < userSettings.swipeDelay)) {
	      console.log('スワイプ操作直後のため返却モーダル表示をスキップします');
	      return;
	    }
	    
	    // 既に開いているモーダルをすべて閉じる
	    closeAllModals();
	    
	    // 貸出データを詳細ログ出力
	    console.log('Rental data for return:', JSON.stringify(rental));
	    
	    // 機材情報取得
	    const equipment = equipmentList.find(item => 
	      String(item['機器管理番号']) === String(rental['機器管理番号'])
	    );
	    
	    if (!equipment) {
	      alert('機材情報の取得に失敗しました');
	      return;
	    }
	    
	    // 返却モーダルの要素取得と設定
	    const modal = document.getElementById('return-modal');
	    if (!modal) {
	      alert('返却モーダル要素が見つかりません');
	      return;
	    }
	    
	    // フォーム要素取得
	    const equipmentField = document.getElementById('return-equipment');
	    const returnDateField = document.getElementById('return-date');
	    const quantitySelect = document.getElementById('return-quantity');
	    
	    if (!equipmentField || !returnDateField || !quantitySelect) {
	      alert('フォーム要素が見つかりません');
	      return;
	    }
	    
	    // 機材情報の設定
	    equipmentField.value = `${equipment['機器名称']} (${rental['機器管理番号']})`;
	    
	    // 返却日に本日の日付を設定
	    const today = new Date();
	    returnDateField.value = formatDate(today);
	    
	    // 選択肢をクリア
	    quantitySelect.innerHTML = '';
	    
	    // 数量の選択肢を追加
	    const maxQuantity = parseInt(rental['数量']) || 1;
	    for (let i = 1; i <= maxQuantity; i++) {
	      const option = document.createElement('option');
	      option.value = i;
	      option.textContent = `${i}台`;
	      quantitySelect.appendChild(option);
	    }
	    
	    // 初期値を設定
	    quantitySelect.value = maxQuantity;
	    
	    // ラベルを浮かせる（Materialize CSS）
	    M.updateTextFields();
	    
	    // 貸出元（定置場所）の情報を保存
	    const sourceLocation = rental['貸出元'] || '';
	    
	    // 保存ボタンにデータ属性を設定
	    const saveReturnBtn = document.getElementById('save-return');
	    if (saveReturnBtn) {
	      saveReturnBtn.dataset.rentalId = rental['登録日時'] ? rental['登録日時'].toString() : '';
	      saveReturnBtn.dataset.sourceLocation = sourceLocation;
	    }
	    
	    // 返却モーダルを表示
	    try {
	      // 既存のインスタンスを取得または新規作成
	      let instance = M.Modal.getInstance(modal);
	      if (!instance) {
	        const modalOptions = {
	          dismissible: true,
	          opacity: 0.5,
	          inDuration: 300,
	          outDuration: 200,
	          preventScrolling: true
	        };
	        instance = M.Modal.init(modal, modalOptions);
	      }
	      instance.open();
	    } catch (error) {
	      console.error('返却モーダル表示エラー:', error);
	      alert('モーダルの表示に失敗しました: ' + error);
	    }
	  } catch (error) {
	    console.error('返却モーダル表示エラー:', error);
	    alert('返却モーダルの表示中にエラーが発生しました: ' + error);
	  }
	  // モーダル表示後に日付ピッカーを初期化
	  setTimeout(() => {
	    setupDatePickers();
	  }, 100);
	}
  
  // 貸出保存関数
  function saveRental() {
    try {
      console.log('貸出登録開始');
      
      // フォーム要素取得
      const equipmentField = document.getElementById('rental-equipment');
      const startDateField = document.getElementById('rental-start');
      const endDateField = document.getElementById('rental-end');
      const quantityField = document.getElementById('rental-quantity');
      const projectSelect = document.getElementById('rental-project');
      const newProjectField = document.getElementById('new-project');
      const sourceLocationField = document.getElementById('rental-source-location');
      
      if (!equipmentField || !startDateField || !endDateField || !quantityField || 
          !projectSelect || !newProjectField || !sourceLocationField) {alert('フォーム要素が見つかりません');
        return;
      }
      
      // 機材ID抽出
      const equipmentValue = equipmentField.value;
      let equipmentId = '';
      
      // 括弧内の文字列を抽出する安全な方法
      const lastOpenBracket = equipmentValue.lastIndexOf('(');
      const lastCloseBracket = equipmentValue.lastIndexOf(')');
      
      if (lastOpenBracket !== -1 && lastCloseBracket !== -1 && lastOpenBracket < lastCloseBracket) {
        equipmentId = equipmentValue.substring(lastOpenBracket + 1, lastCloseBracket).trim();
      } else {
        alert('機材情報の形式が不正です');
        return;
      }
      
      const startDate = startDateField.value;
      const endDate = endDateField.value;
      const quantity = parseInt(quantityField.value);
      const sourceLocation = sourceLocationField.value;
      
      // 現場の取得（選択または新規入力）
      let project = projectSelect.value;
      const newProject = newProjectField.value.trim();
      
      if (newProject !== '') {
        project = newProject;
      }
      
      // バリデーション
      if (!startDate || !endDate) {
        alert('日付を入力してください');
        return;
      }
      
      if (!quantity || isNaN(quantity) || quantity <= 0) {
        alert('有効な数量を入力してください');
        return;
      }
      
      if (!project) {
        alert('現場名を選択または入力してください');
        return;
      }
      
      if (new Date(startDate) > new Date(endDate)) {
        alert('借用開始日は借用終了日より前にしてください');
        return;
      }
      
      // 機材情報取得（選択された定置場所との組み合わせで）
      const equipment = equipmentList.find(item => 
        String(item['機器管理番号']) === String(equipmentId) && 
        String(item['定置場所'] || '') === String(sourceLocation)
      );
      
      if (!equipment) {
        alert(`機材情報の取得に失敗しました。\n機器管理番号: ${equipmentId}\n定置場所: ${sourceLocation}`);
        return;
      }
      
      // 総台数チェック
      const totalQuantity = parseInt(equipment['総台数']) || 0;
      
      if (quantity > totalQuantity) {
        alert(`この定置場所の在庫は${totalQuantity}台です。\n数量は1～${totalQuantity}の間で入力してください。`);
        return;
      }
      
      // 貸出可能チェック（定置場所を考慮）
      if (!checkAvailability(equipmentId, sourceLocation, startDate, endDate, quantity)) {
        return;
      }
      
      // スクロール位置を保存
      saveScrollPosition();
      
      // データ準備
      const data = {
        equipmentId: equipmentId,
        equipmentName: equipment['機器名称'],
        startDate: startDate,
        endDate: endDate,
        quantity: quantity,
        project: project,
        sourceLocation: sourceLocation // 貸出元の定置場所
      };
      
      console.log('送信データ:', data);
      
      // 登録前にモーダルを閉じる
      try {
        const modal = document.getElementById('rental-modal');
        const instance = M.Modal.getInstance(modal);
        if (instance) instance.close();
      } catch (error) {
        console.error('モーダル閉じるエラー:', error);
      }
      
      // 保存API実行
      showLoading();
      google.script.run
        .withSuccessHandler(function(response) {
          hideLoading();
          
          if (response && response.success) {
            // 成功処理
            console.log('保存成功:', response);
            
            // Undoスタック追加
            undoStack.push({
              action: 'deleteRental',
              id: response.id
            });
            
            // Undoボタン有効化
            const undoButton = document.getElementById('undo-button');
            if (undoButton) undoButton.disabled = false;
            
            // 現場リスト再取得（新しい現場が追加された可能性あり）
            getProjectsList();
            
            // 成功メッセージ
            alert('貸出を登録しました');
          } else {
            // 失敗処理
            console.error('保存失敗:', response);
            alert('貸出登録に失敗しました: ' + (response ? response.error : '不明なエラー'));
          }
        })
        .withFailureHandler(function(error) {
          hideLoading();
          console.error('保存エラー:', error);
          alert('貸出登録に失敗しました: ' + error);
        })
        .saveRental(data);
    } catch (error) {
      console.error('貸出保存エラー:', error);
      alert('貸出保存処理でエラーが発生しました: ' + error);
    }
  }
  
  // 返却保存関数
  function saveReturn() {
    try {
      console.log('返却登録開始');
      
      // 保存ボタンからID取得
      const saveReturnBtn = document.getElementById('save-return');
      if (!saveReturnBtn) {
        alert('返却ボタンが見つかりません');
        return;
      }
      
      // データ属性とHTML属性の両方から取得を試みる
      let rentalId = saveReturnBtn.dataset.rentalId || saveReturnBtn.getAttribute('data-rental-id');
      
      console.log('Button rental ID:', rentalId);
      
      if (!rentalId) {
        alert('返却データのIDが取得できません');
        return;
      }
      
      const sourceLocation = saveReturnBtn.dataset.sourceLocation || saveReturnBtn.getAttribute('data-source-location') || '';
      
      // フォーム要素取得
      const returnDateField = document.getElementById('return-date');
      const quantitySelect = document.getElementById('return-quantity');
      
      if (!returnDateField || !quantitySelect) {
        alert('フォーム要素が見つかりません');
        return;
      }
      
      const returnDate = returnDateField.value;
      const returnQuantity = parseInt(quantitySelect.value) || 0;
      
      // バリデーション
      if (!returnDate) {
        alert('返却日を入力してください');
        return;
      }
      
      if (returnQuantity <= 0) {
        alert('返却台数を選択してください');
        return;
      }
      
      // 該当の貸出データが存在するか確認
      let rental = rentalData.find(item => item['登録日時'] && item['登録日時'].toString() === rentalId);
      
      // 完全一致しない場合は部分一致で検索
      if (!rental) {
        console.log('完全一致する貸出データが見つかりません。部分一致で検索します。');
        
        rental = rentalData.find(item => {
          if (!item['登録日時']) return false;
          
          const itemId = item['登録日時'].toString();
          return itemId.includes(rentalId) || rentalId.includes(itemId);
        });
      }
      
      if (!rental) {
        alert('該当する貸出データが見つかりません。画面をリロードして再試行してください。');
        
        // デバッグ情報を表示
        console.log('Rental ID:', rentalId);
        console.log('Available rental data:', rentalData);
        
        return;
      }
      
      // スクロール位置を保存
      saveScrollPosition();
      
      // データ準備
      const data = {
        rentalId: rental['登録日時'].toString(), // 確実に見つかった貸出の正しいIDを使用
        returnDate: returnDate,
        returnQuantity: returnQuantity,
        returnLocation: sourceLocation  // 貸出元と同じ場所に返却
      };
      
      console.log('送信データ:', data);
      
      // 登録前にモーダルを閉じる
      try {
        const modal = document.getElementById('return-modal');
        const instance = M.Modal.getInstance(modal);
        if (instance) instance.close();
      } catch (error) {
        console.error('モーダル閉じるエラー:', error);
      }
      
      // 保存API実行
      showLoading();
      google.script.run
        .withSuccessHandler(function(response) {
          if (response && response.success) {
            // 成功処理
            console.log('保存成功:', response);
            
            // Undoスタック追加
            undoStack.push({
              action: 'undoReturn',
              id: rental['登録日時'].toString() // 確実に正しいIDを使用
            });
            
            // Undoボタン有効化
            const undoButton = document.getElementById('undo-button');
            if (undoButton) undoButton.disabled = false;
            
            // データ再読み込み - 最新の貸出データを取得
            google.script.run
              .withSuccessHandler(function(rentalDataResponse) {
                hideLoading();
                
                if (rentalDataResponse && Array.isArray(rentalDataResponse)) {
                  // 日付文字列をDateオブジェクトに変換
                  const processedData = rentalDataResponse.map(item => {
                    // 各プロパティの型確認
                    Object.keys(item).forEach(key => {
                      if (key === '借用開始日' || key === '借用終了日' || key === '登録日時' || key === '返却日') {
                        if (item[key] && typeof item[key] === 'string') {
                          item[key] = new Date(item[key]);
                        }
                      }
                    });
                    
                    // ステータスが設定されていない場合、返却日に基づいて判定
                    if (!item['ステータス']) {
                      item['ステータス'] = item['返却日'] ? '返却済み' : '貸出中';
                    }
                    
                    return item;
                  });
                  
                  rentalData = processedData;
                  updateGanttChart();
                  
                  // 成功メッセージ
                  alert('返却を登録しました');
                } else {
                  rentalData = [];
                  updateGanttChart();
                  alert('返却を登録しましたが、データの再取得に失敗しました');
                }
              })
              .withFailureHandler(function(error) {
                hideLoading();
                console.error('貸出データ再取得失敗:', error);
                // エラー時も古いデータでチャートを更新
                updateGanttChart();
                alert('返却を登録しました');
              })
              .getRentalData();
          } else {
            // 失敗処理
            hideLoading();
            console.error('保存失敗:', response);
            alert('返却登録に失敗しました: ' + (response ? response.error : '不明なエラー'));
          }
        })
        .withFailureHandler(function(error) {
          hideLoading();
          console.error('保存エラー:', error);
          alert('返却登録に失敗しました: ' + error);
        })
        .saveReturn(data);
    } catch (error) {
      console.error('返却保存エラー:', error);
      alert('返却保存処理でエラーが発生しました: ' + error);
    }
  }
  
  // 貸出可能チェック
  function checkAvailability(equipmentId, sourceLocation, startDate, endDate, requestedQuantity) {
    try {
      // 機材情報取得（機器管理番号と定置場所で絞り込み）
      const equipment = equipmentList.find(item => 
        String(item['機器管理番号']) === String(equipmentId) && 
        String(item['定置場所'] || '') === String(sourceLocation)
      );
      
      if (!equipment) {
        alert(`機材情報の取得に失敗しました。\n機器管理番号: ${equipmentId}\n定置場所: ${sourceLocation}`);
        return false;
      }
      
      const totalQuantity = parseInt(equipment['総台数']) || 0;
      
      // 日付範囲
      const start = new Date(startDate);
      const end = new Date(endDate);
      
      // 各日にちで利用可能数チェック
      let currentDate = new Date(start);
      
      while (currentDate <= end) {
        const dateStr = formatDate(currentDate);
        let rentedQuantity = 0;
        
        // この日付で貸出中の数量を計算（該当の定置場所からの貸出のみ集計）
        rentalData.forEach(rental => {
          if (!rental) return;
          
          // この機材の貸出（同じ機器管理番号 AND 同じ貸出元）
          if (String(rental['機器管理番号']) === String(equipmentId) && 
              String(rental['貸出元'] || '') === String(sourceLocation)) {
              
            // ステータスが返却済みの場合はスキップ
            if (rental['ステータス'] === '返却済み') return;
            
            // 返却日がある場合も返却済みとみなしてスキップ
            if (rental['返却日'] && rental['ステータス'] === '返却済み') return;
            
            // 日付型変換
            let rentalStart = parseDate(rental['借用開始日']);
            let rentalEnd = parseDate(rental['借用終了日']);
            
            // 日付有効性チェック
            if (!rentalStart || !rentalEnd) {
              return;
            }
            
            // 日付範囲チェック
            if (rentalStart <= currentDate && rentalEnd >= currentDate) {
              rentedQuantity += parseInt(rental['数量']) || 0;
            }
          }
        });
        
        // 利用可能数チェック
        const availableQuantity = totalQuantity - rentedQuantity;
        
        if (requestedQuantity > availableQuantity) {
          alert(`${dateStr}には${availableQuantity}台しか利用できません。期間または数量を変更してください。`);
          return false;
        }
        
        // 次の日へ
        currentDate.setDate(currentDate.getDate() + 1);
      }
      
      return true;
    } catch (error) {
      console.error('貸出可能チェックエラー:', error);
      alert('貸出可能性のチェックに失敗しました: ' + error);
      return false;
    }
  }
  
  // Undo実行
  function executeUndo(action) {
    if (!action || !action.action || !action.id) {
      console.error('無効なUndo操作:', action);
      return;
    }
    
    showLoading();
    
    switch (action.action) {
      case 'deleteRental':
        google.script.run
          .withSuccessHandler(function(response) {
            hideLoading();
            
            if (response && response.success) {
              // データ再取得
              google.script.run
                .withSuccessHandler(function(rentalDataResponse) {
                  if (rentalDataResponse && Array.isArray(rentalDataResponse)) {
                    // 日付文字列をDateオブジェクトに変換して保存
                    rentalData = rentalDataResponse.map(item => {
                      Object.keys(item).forEach(key => {
                        if (key === '借用開始日' || key === '借用終了日' || key === '登録日時' || key === '返却日') {
                          if (item[key] && typeof item[key] === 'string') {
                            item[key] = new Date(item[key]);
                          }
                        }
                      });
                      
                      if (!item['ステータス']) {
                        item['ステータス'] = item['返却日'] ? '返却済み' : '貸出中';
                      }
                      
                      return item;
                    });
                  } else {
                    rentalData = [];
                  }
                  
                  updateGanttChart();
                })
                .withFailureHandler(function(error) {
                  console.error('貸出データ再取得失敗:', error);
                  updateGanttChart();
                })
                .getRentalData();
              
              alert('貸出登録を取り消しました');
            } else {
              alert('取消に失敗しました: ' + (response ? response.error : '不明なエラー'));
            }
          })
          .withFailureHandler(function(error) {
            hideLoading();
            console.error('Undoエラー:', error);
            alert('取消に失敗しました: ' + error);
          })
          .deleteRental(action.id);
        break;
        
      case 'undoReturn':
        google.script.run
          .withSuccessHandler(function(response) {
            hideLoading();
            
            if (response && response.success) {
              // データ再取得
              google.script.run
                .withSuccessHandler(function(rentalDataResponse) {
                  if (rentalDataResponse && Array.isArray(rentalDataResponse)) {
                    // 日付文字列をDateオブジェクトに変換して保存
                    rentalData = rentalDataResponse.map(item => {
                      Object.keys(item).forEach(key => {
                        if (key === '借用開始日' || key === '借用終了日' || key === '登録日時' || key === '返却日') {
                          if (item[key] && typeof item[key] === 'string') {
                            item[key] = new Date(item[key]);
                          }
                        }
                      });
                      
                      if (!item['ステータス']) {
                        item['ステータス'] = item['返却日'] ? '返却済み' : '貸出中';
                      }
                      
                      return item;
                    });
                  } else {
                    rentalData = [];
                  }
                  
                  updateGanttChart();
                })
                .withFailureHandler(function(error) {
                  console.error('貸出データ再取得失敗:', error);
                  updateGanttChart();
                })
                .getRentalData();
              
              alert('返却を取り消しました');
            } else {
              alert('取消に失敗しました: ' + (response ? response.error : '不明なエラー'));
            }
          })
          .withFailureHandler(function(error) {
            hideLoading();
            console.error('Undoエラー:', error);
            alert('取消に失敗しました: ' + error);
          })
          .undoReturn(action.id);
        break;
        
      default:
        hideLoading();
        console.error('不明なUndo操作:', action);
    }
  }
  
  // 日付フォーマット
  function formatDate(date, format = 'yyyy-MM-dd') {
    try {
      if (!date) return '';
      
      if (!(date instanceof Date)) {
        date = new Date(date);
      }
      
      if (isNaN(date.getTime())) {
        console.error('無効な日付:', date);
        return '';
      }
      
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      
      if (format === 'yyyy-MM-dd') {
        return `${year}-${month}-${day}`;
      } else if (format === 'MM/dd') {
        return `${month}/${day}`;
      }
      
      return `${year}-${month}-${day}`;
    } catch (error) {
      console.error('日付フォーマットエラー:', error);
      return '';
    }
  }
  
  // ローディング表示
  function showLoading() {
    try {
      const loading = document.getElementById('loading');
      if (loading) loading.classList.remove('hidden');
    } catch (error) {
      console.error('ローディング表示エラー:', error);
    }
  }
  
  // ローディング非表示
  function hideLoading() {
    try {
      const loading = document.getElementById('loading');
      if (loading) loading.classList.add('hidden');
    } catch (error) {
      console.error('ローディング非表示エラー:', error);
    }
  }
  
  // 現場マスター管理モーダルを開く
	function openProjectsModal() {
	  try {
	    console.log('現場マスター管理モーダル表示');
	    
	    // 現場リストが空の場合は先に取得する
	    if (!projectsList || projectsList.length === 0) {
	      showLoading();
	      google.script.run
	        .withSuccessHandler(function(data) {
	          hideLoading();
	          if (data && Array.isArray(data)) {
	            projectsList = data;
	          } else {
	            projectsList = [];
	          }
	          // 現場リストをテーブルに表示
	          updateProjectsTable();
	          showProjectsModal();
	        })
	        .withFailureHandler(function(error) {
	          hideLoading();
	          console.error('現場リスト取得エラー:', error);
	          projectsList = [];
	          updateProjectsTable();
	          showProjectsModal();
	        })
	        .getProjectsList();
	    } else {
	      // 現場リストをテーブルに表示
	      updateProjectsTable();
	      showProjectsModal();
	    }
	  } catch (error) {
	    console.error('現場マスター管理モーダル表示エラー:', error);
	  }
	}
	
	
  // モーダル表示部分を分離
	function showProjectsModal() {
	  // モーダル表示
	  const modal = document.getElementById('projects-modal');
	  if (!modal) {
	    alert('モーダル要素が見つかりません');
	    return;
	  }
	  
	  try {
	    // 既存のインスタンスを削除
	    const oldInstance = M.Modal.getInstance(modal);
	    if (oldInstance) {
	      oldInstance.destroy();
	    }
	    
	    // 新しいインスタンスを作成して開く
	    const modalOptions = {
	      dismissible: true,
	      opacity: 0.5,
	      inDuration: 300,
	      outDuration: 200,
	      preventScrolling: true
	    };
	    
	    setTimeout(() => {
	      const instance = M.Modal.init(modal, modalOptions);
	      instance.open();
	    }, 50);
	  } catch (error) {
	    console.error('現場マスターモーダル表示エラー:', error);
	    alert('モーダルの表示に失敗しました: ' + error);
	  }
	}
  
  // 現場リストをテーブルに表示
  function updateProjectsTable() {
    try {
      const tableBody = document.getElementById('projects-list');
      if (!tableBody) return;
      
      // 既存の行をクリア
      tableBody.innerHTML = '';
      
      if (!projectsList || projectsList.length === 0) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = 3;
        emptyCell.textContent = '登録されている現場はありません';
        emptyCell.style.textAlign = 'center';
        emptyRow.appendChild(emptyCell);
        tableBody.appendChild(emptyRow);
        return;
      }
      
      // 現場をあいうえお順にソート
      const sortedProjects = [...projectsList].sort((a, b) => 
        String(a.name).localeCompare(String(b.name), 'ja')
      );
      
      // 現場の行を作成
      sortedProjects.forEach(project => {
        const row = document.createElement('tr');
        
        // チェックボックスセル
        const checkCell = document.createElement('td');
        const checkboxLabel = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'filled-in project-checkbox';
        checkbox.dataset.projectName = project.name;
        const checkboxSpan = document.createElement('span');
        checkboxLabel.appendChild(checkbox);
        checkboxLabel.appendChild(checkboxSpan);
        checkCell.appendChild(checkboxLabel);
        
        // 現場名セル
        const nameCell = document.createElement('td');
        nameCell.textContent = project.name;
        
        // 作成日セル
        const dateCell = document.createElement('td');
        if (project.createdAt) {
          const createdDate = new Date(project.createdAt);
          dateCell.textContent = formatDate(createdDate);
        } else {
          dateCell.textContent = '不明';
        }
        
        // 行に追加
        row.appendChild(checkCell);
        row.appendChild(nameCell);
        row.appendChild(dateCell);
        
        // テーブルに追加
        tableBody.appendChild(row);
      });
    } catch (error) {
      console.error('現場テーブル更新エラー:', error);
    }
  }
  
  // 現場を追加
  function addProject() {
    try {
      const projectNameField = document.getElementById('new-project-name');
      if (!projectNameField) {
        alert('フォーム要素が見つかりません');
        return;
      }
      
      const projectName = projectNameField.value.trim();
      if (!projectName) {
        alert('現場名を入力してください');
        return;
      }
      
      // 現場追加API実行
      showLoading();
      google.script.run
        .withSuccessHandler(function(response) {
          hideLoading();
          
          if (response && response.success) {
            // 成功処理
            console.log('現場追加成功:', response);
            
            // 入力フィールドをクリア
            projectNameField.value = '';
            
            // 現場リスト再取得して一覧を更新
            google.script.run
              .withSuccessHandler(function(data) {
                if (data && Array.isArray(data)) {
                  projectsList = data;
                  // 現場一覧テーブルを更新
                  updateProjectsTable();
                }
              })
              .getProjectsList();
            
            // 成功メッセージ
            if (response.message) {
              alert(response.message);
            } else {
              alert('現場を追加しました');
            }
          } else {
            // 失敗処理
            console.error('現場追加失敗:', response);
            alert('現場の追加に失敗しました: ' + (response ? response.error : '不明なエラー'));
          }
        })
        .withFailureHandler(function(error) {
          hideLoading();
          console.error('現場追加エラー:', error);
          alert('現場の追加に失敗しました: ' + error);
        })
        .addProject({ name: projectName });
    } catch (error) {
      console.error('現場追加エラー:', error);
      hideLoading();
      alert('現場の追加に失敗しました: ' + error);
    }
  }
  
  // 現場を削除
  function deleteProjects() {
    try {
      // 選択された現場を取得
      const checkboxes = document.querySelectorAll('.project-checkbox:checked');
      if (checkboxes.length === 0) {
        alert('削除する現場を選択してください');
        return;
      }
      
      // 確認ダイアログ
      if (!confirm(`選択された ${checkboxes.length} 件の現場を削除してもよろしいですか？`)) {
        return;
      }
      
      // 選択された現場名のリストを作成
      const projectNames = Array.from(checkboxes).map(checkbox => checkbox.dataset.projectName);
      
      // 現場削除API実行
      showLoading();
      google.script.run
        .withSuccessHandler(function(response) {
          hideLoading();
          
          if (response && response.success) {
            // 成功処理
            console.log('現場削除成功:', response);
            
            // 現場リスト再取得して一覧を更新
            google.script.run
              .withSuccessHandler(function(data) {
                if (data && Array.isArray(data)) {
                  projectsList = data;
                  updateProjectsTable();
                }
              })
              .getProjectsList();
            
            // 成功メッセージ
            alert(`${response.deletedCount || projectNames.length} 件の現場を削除しました`);
          } else {
            // 失敗処理
            console.error('現場削除失敗:', response);
            alert('現場の削除に失敗しました: ' + (response ? response.error : '不明なエラー'));
          }
        })
        .withFailureHandler(function(error) {
          hideLoading();
          console.error('現場削除エラー:', error);
          alert('現場の削除に失敗しました: ' + error);
        })
        .deleteProjects({ names: projectNames });
    } catch (error) {
      console.error('現場削除エラー:', error);
      hideLoading();
      alert('現場の削除に失敗しました: ' + error);
    }
  }
  
  // 機器マスター管理モーダルを開く
	function openEquipmentModal() {
	  try {
	    console.log('機器マスター管理モーダル表示');
	    
	    // 機器リストをテーブルに表示
	    updateEquipmentTable();
	    
	    // 定置場所リストを選択肢に追加
	    updateLocationSelect();
	    
	    // モーダル表示
	    const modal = document.getElementById('equipment-modal');
	    if (!modal) {
	      alert('モーダル要素が見つかりません');
	      return;
	    }
	    
	    try {
	      // 既存のインスタンスを削除
	      const oldInstance = M.Modal.getInstance(modal);
	      if (oldInstance) {
	        oldInstance.destroy();
	      }
	      
	      // 新しいインスタンスを作成して開く
	      const modalOptions = {
	        dismissible: true,
	        opacity: 0.5,
	        inDuration: 300,
	        outDuration: 200,
	        preventScrolling: true
	      };
	      
	      setTimeout(() => {
	        const instance = M.Modal.init(modal, modalOptions);
	        instance.open();
	      }, 50);
	    } catch (error) {
	      console.error('機器マスターモーダル表示エラー:', error);
	      alert('モーダルの表示に失敗しました: ' + error);
	    }
	  } catch (error) {
	    console.error('機器マスター管理モーダル表示エラー:', error);
	  }
	}
  
  // 機器リストをテーブルに表示
  function updateEquipmentTable() {
    try {
      const tableBody = document.getElementById('equipment-list');
      if (!tableBody) return;
      
      // 既存の行をクリア
      tableBody.innerHTML = '';
      
      if (!equipmentList || equipmentList.length === 0) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = 7;
        emptyCell.textContent = '登録されている機器はありません';
        emptyCell.style.textAlign = 'center';
        emptyRow.appendChild(emptyCell);
        tableBody.appendChild(emptyRow);
        return;
      }
      
      // 機器をあいうえお順にソート
      const sortedEquipment = [...equipmentList].sort((a, b) => 
        String(a['機器名称'] || '').localeCompare(String(b['機器名称'] || ''), 'ja')
      );
      
      // 機器の行を作成
      sortedEquipment.forEach(equipment => {
        const row = document.createElement('tr');
        
        // チェックボックスセル
        const checkCell = document.createElement('td');
        const checkboxLabel = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'filled-in equipment-checkbox';
        checkbox.dataset.equipmentId = equipment['機器管理番号'];
        const checkboxSpan = document.createElement('span');
        checkboxLabel.appendChild(checkbox);
        checkboxLabel.appendChild(checkboxSpan);
        checkCell.appendChild(checkboxLabel);
        
        // 管理番号セル
        const idCell = document.createElement('td');
        idCell.textContent = equipment['機器管理番号'];
        
        // 機器名称セル
        const nameCell = document.createElement('td');
        nameCell.textContent = equipment['機器名称'];
        
        // 型番セル
        const modelCell = document.createElement('td');
        modelCell.textContent = equipment['型番'] || '';
        
        // メーカーセル
        const makerCell = document.createElement('td');
        makerCell.textContent = equipment['メーカー'] || '';
        
        // 総台数セル
        const quantityCell = document.createElement('td');
        quantityCell.textContent = equipment['総台数'] || '0';
        
        // 定置場所セル
        const locationCell = document.createElement('td');
        locationCell.textContent = equipment['定置場所'] || '';
        
        // 行に追加
        row.appendChild(checkCell);
        row.appendChild(idCell);
        row.appendChild(nameCell);
        row.appendChild(modelCell);
        row.appendChild(makerCell);
        row.appendChild(quantityCell);
        row.appendChild(locationCell);
        
        // テーブルに追加
        tableBody.appendChild(row);
      });
    } catch (error) {
      console.error('機器テーブル更新エラー:', error);
    }
  }
  
  // 定置場所選択肢の更新
  function updateLocationSelect() {
    try {
      const locationSelect = document.getElementById('new-equipment-location');
      if (!locationSelect) return;
      
      // 既存の選択肢をクリア（最初のオプションは残す）
      while (locationSelect.options.length > 1) {
        locationSelect.remove(1);
      }
      
      // 定置場所リストを追加
      if (locationsList && locationsList.length > 0) {
        locationsList.forEach(location => {
          const option = document.createElement('option');
          option.value = location;
          option.textContent = location;
          locationSelect.appendChild(option);
        });
      }
    } catch (error) {
      console.error('定置場所選択肢更新エラー:', error);
    }
  }
  
  // 機器を追加
  function addEquipment() {
    try {
      // フォーム要素の取得
      const nameField = document.getElementById('new-equipment-name');
      const specField = document.getElementById('new-equipment-spec');
      const modelField = document.getElementById('new-equipment-model');
      const makerField = document.getElementById('new-equipment-maker');
      const serialField = document.getElementById('new-equipment-serial');
      const quantityField = document.getElementById('new-equipment-quantity');
      const aliasField = document.getElementById('new-equipment-alias');
      const locationSelect = document.getElementById('new-equipment-location');
      const note1Field = document.getElementById('new-equipment-note1');
      const note2Field = document.getElementById('new-equipment-note2');
      
      // 必須項目のチェック
      if (!nameField || !quantityField) {
        alert('フォーム要素が見つかりません');
        return;
      }
      
      const name = nameField.value.trim();
      const quantity = quantityField.value.trim();
      
      if (!name) {
        alert('機器名称を入力してください');
        nameField.focus();
        return;
      }
      
      if (!quantity || isNaN(parseInt(quantity)) || parseInt(quantity) <= 0) {
        alert('有効な総台数（1以上の整数）を入力してください');
        quantityField.focus();
        return;
      }
      
      // データの準備
      const data = {
        name: name,
        spec: specField ? specField.value : '',
        model: modelField ? modelField.value : '',
        maker: makerField ? makerField.value : '',
        serialNo: serialField ? serialField.value : '',
        quantity: parseInt(quantity),
        alias: aliasField ? aliasField.value : '',
        location: locationSelect ? locationSelect.value : '',
        note1: note1Field ? note1Field.value : '',
        note2: note2Field ? note2Field.value : ''
      };
      
      // 機器追加API実行
      showLoading();
      google.script.run
        .withSuccessHandler(function(response) {
          hideLoading();
          
          if (response && response.success) {
            // 成功処理
            console.log('機器追加成功:', response);
            
            // 入力フィールドをクリア
            nameField.value = '';
            if (specField) specField.value = '';
            if (modelField) modelField.value = '';
            if (makerField) makerField.value = '';
            if (serialField) serialField.value = '';
            quantityField.value = '';
            if (aliasField) aliasField.value = '';
            if (locationSelect) locationSelect.value = '';
            if (note1Field) note1Field.value = '';
            if (note2Field) note2Field.value = '';
            
            // 機材リスト再取得
            getEquipmentList();
            
            // フォーム要素のラベルを元に戻す
            document.querySelectorAll('#equipment-modal .input-field label').forEach(label => {
              label.classList.remove('active');
            });
            
            // 成功メッセージ
            alert(`機器管理番号「${response.equipmentId}」で機器を追加しました`);
          } else {
            // 失敗処理
            console.error('機器追加失敗:', response);
            alert('機器の追加に失敗しました: ' + (response ? response.error : '不明なエラー'));
          }
        })
        .withFailureHandler(function(error) {
          hideLoading();
          console.error('機器追加エラー:', error);
          alert('機器の追加に失敗しました: ' + error);
        })
        .addEquipment(data);
    } catch (error) {
      console.error('機器追加エラー:', error);
      hideLoading();
      alert('機器の追加に失敗しました: ' + error);
    }
  }
  
  // 機器を削除
  function deleteEquipment() {
    try {
      // 選択された機器を取得
      const checkboxes = document.querySelectorAll('.equipment-checkbox:checked');
      if (checkboxes.length === 0) {
        alert('削除する機器を選択してください');
        return;
      }
      
      // 確認ダイアログ
      if (!confirm(`選択された ${checkboxes.length} 件の機器を削除してもよろしいですか？`)) {
        return;
      }
      
      // 選択された機器IDのリストを作成
      const equipmentIds = Array.from(checkboxes).map(checkbox => checkbox.dataset.equipmentId);
      
      // 機器削除API実行
      showLoading();
      google.script.run
        .withSuccessHandler(function(response) {
          hideLoading();
          
          if (response && response.success) {
            // 成功処理
            console.log('機器削除成功:', response);
            
            // 削除タイムスタンプを保存
            lastDeletedEquipment = response.timestamp;
            
            // 機材リスト再取得
            getEquipmentList();
            
            // 成功メッセージ
            alert(`${response.deletedCount || equipmentIds.length} 件の機器を削除しました`);
          } else {
            // 失敗処理
            console.error('機器削除失敗:', response);
            alert('機器の削除に失敗しました: ' + (response ? response.error : '不明なエラー'));
          }
        })
        .withFailureHandler(function(error) {
          hideLoading();
          console.error('機器削除エラー:', error);
          alert('機器の削除に失敗しました: ' + error);
        })
        .deleteEquipments({ ids: equipmentIds });
    } catch (error) {
      console.error('機器削除エラー:', error);
      hideLoading();
      alert('機器の削除に失敗しました: ' + error);
    }
  }
  
  // 機器削除の取り消し
  function undoEquipmentDelete() {
    try {
      if (!lastDeletedEquipment) {
        alert('元に戻せる削除操作がありません');
        return;
      }
      
      // 確認ダイアログ
      if (!confirm('最後に削除した機器を復元しますか？')) {
        return;
      }
      
      // 機器削除アンドゥAPI実行
      showLoading();
      google.script.run
        .withSuccessHandler(function(response) {
          hideLoading();
          
          if (response && response.success) {
            // 成功処理
            console.log('機器復元成功:', response);
            
            // 復元タイムスタンプをクリア
            lastDeletedEquipment = null;
            
            // 機材リスト再取得
            getEquipmentList();
            
            // 成功メッセージ
            alert(`${response.restoredCount || 0} 件の機器を復元しました`);
          } else {
            // 失敗処理
            console.error('機器復元失敗:', response);
            alert('機器の復元に失敗しました: ' + (response ? response.error : '不明なエラー'));
          }
        })
        .withFailureHandler(function(error) {
          hideLoading();
          console.error('機器復元エラー:', error);
          alert('機器の復元に失敗しました: ' + error);
        })
        .undoEquipmentDelete({ timestamp: lastDeletedEquipment });
    } catch (error) {
      console.error('機器復元エラー:', error);
      hideLoading();
      alert('機器の復元に失敗しました: ' + error);
    }
  }
  
  // 設定を読み込む関数
  function loadUserSettings() {
    try {
      const savedSettings = localStorage.getItem('rentalSystemSettings');
      if (savedSettings) {
        userSettings = JSON.parse(savedSettings);
      }
      
      // フォントサイズの初期値
      if (!localStorage.getItem('mobileFontSize')) {
        localStorage.setItem('mobileFontSize', '30');
      }
      
      // 設定UIの状態を反映
      updateSettingsUI();
    } catch (error) {
      console.error('設定の読み込みに失敗しました:', error);
    }
  }

  // 設定を保存する関数
  function saveUserSettings() {
    try {
      localStorage.setItem('rentalSystemSettings', JSON.stringify(userSettings));
    } catch (error) {
      console.error('設定の保存に失敗しました:', error);
    }
  }

  // 設定UIの状態を更新する関数
  function updateSettingsUI() {
    const confirmDialogCheckbox = document.getElementById('confirm-dialog-checkbox');
    if (confirmDialogCheckbox) {
      confirmDialogCheckbox.checked = userSettings.showConfirmDialog;
    }
  }
  
  // ユーザーのメールアドレスから表示名を取得する関数
  function getUserDisplayName(email) {
    if (!email) return '';
    
    // メールアドレスと一致するユーザーがいれば表示名を使用
    if (email === userEmail) {
      return userName;
    }
    
    // それ以外はメールアドレスの@前を表示
    return email.split('@')[0];
  }
  
  // 機材詳細情報の行を追加するヘルパー関数
  function addDetailLine(container, label, value) {
    if (!value) return;
    
    const detailDiv = document.createElement('div');
    detailDiv.className = 'equipment-detail';
    detailDiv.textContent = `${label}: ${value}`;
    container.appendChild(detailDiv);
  }

  // バーのドラッグとリサイズを有効化する関数（改善版）
	function enableBarDragAndResize(bar, rental) {
	  if (!bar) return;
	  
	  // 返却ボタンを作成（バーの右側に配置）
	  const returnButton = document.createElement('div');
	  returnButton.className = 'return-button';
	  returnButton.innerHTML = '<i class="material-icons" style="font-size: 18px;">assignment_return</i>';
	  returnButton.style.position = 'absolute';
	  returnButton.style.right = '5px'; // 右側に配置
	  returnButton.style.top = '50%';
	  returnButton.style.transform = 'translateY(-50%)';
	  returnButton.style.width = '28px';
	  returnButton.style.height = '28px';
	  returnButton.style.borderRadius = '50%';
	  returnButton.style.backgroundColor = 'rgba(255,255,255,0.3)';
	  returnButton.style.display = 'flex';
	  returnButton.style.alignItems = 'center';
	  returnButton.style.justifyContent = 'center';
	  returnButton.style.cursor = 'pointer';
	  returnButton.style.zIndex = '30'; // リサイズハンドルより高い値に設定
	  
	  // 返却ボタンのクリックイベント - 修正版
	  returnButton.addEventListener('click', function(e) {
	    // イベント伝播を停止
	    e.stopPropagation();
	    e.preventDefault();
	  
	    console.log('Return button clicked');
	    
	    // すべてのモーダルを閉じる
	    closeAllModals();
	  
	    // 少し遅延させて返却モーダルを表示
	    setTimeout(() => {
	      showReturnModal(rental);
	    }, 100);
	  
	    return false;
	  });
	  
	  // ドラッグハンドルを作成（バーの中央部分）
	  const dragHandle = document.createElement('div');
	  dragHandle.className = 'drag-handle';
	  dragHandle.style.position = 'absolute';
	  dragHandle.style.width = 'calc(100% - 60px)'; // 左右のリサイズハンドル+返却ボタン用に余白を広げる
	  dragHandle.style.height = '100%';
	  dragHandle.style.left = '30px'; // 左側余白を広げる
	  dragHandle.style.top = '0';
	  dragHandle.style.cursor = 'move';
	  dragHandle.style.zIndex = '5';
	  
	  // 左リサイズハンドルを作成
	  const leftResizeHandle = document.createElement('div');
	  leftResizeHandle.className = 'resize-handle left-handle';
	  leftResizeHandle.style.position = 'absolute';
	  leftResizeHandle.style.width = '20px'; // 幅を広げる
	  leftResizeHandle.style.height = '100%';
	  leftResizeHandle.style.left = '0';
	  leftResizeHandle.style.top = '0';
	  leftResizeHandle.style.cursor = 'w-resize';
	  leftResizeHandle.style.zIndex = '20'; // より高いz-indexに設定
	  
	  // 右リサイズハンドルを作成
	  const rightResizeHandle = document.createElement('div');
	  rightResizeHandle.className = 'resize-handle right-handle';
	  rightResizeHandle.style.position = 'absolute';
	  rightResizeHandle.style.width = '20px'; // 幅を広げる
	  rightResizeHandle.style.height = '100%';
	  rightResizeHandle.style.right = '0';
	  rightResizeHandle.style.top = '0';
	  rightResizeHandle.style.cursor = 'e-resize';
	  rightResizeHandle.style.zIndex = '20'; // より高いz-indexに設定
	  
	  // モバイル用追加処理
	  if (('ontouchstart' in window || navigator.maxTouchPoints > 0)) {
	    setupMobileBarEvents(bar, leftResizeHandle, rightResizeHandle, dragHandle, rental);
	  }
	  
	  // バーに追加
	  bar.appendChild(dragHandle);
	  bar.appendChild(leftResizeHandle);
	  bar.appendChild(rightResizeHandle);
	  bar.appendChild(returnButton);
	  
	  // バー全体のクリックイベントを削除（競合防止）
	  bar.onclick = null;
	  bar.classList.add('editable');
	  
	  // ドラッグハンドルのイベント設定
	  dragHandle.addEventListener('mousedown', function(e) {
	    e.stopPropagation();
	    
	    const timeline = bar.closest('.gantt-timeline');
	    if (!timeline) return;
	    
	    // 貸出情報取得
	    const rentalId = bar.dataset.rentalId;
	    const rental = rentalData.find(item => item['登録日時'] && item['登録日時'].toString() === rentalId);
	    
	    if (!rental) {
	      console.error('貸出情報の取得に失敗しました');
	      return;
	    }
	    
	    // ドラッグ開始
	    isDraggingBar = true;
	    dragBarMode = 'move';
	    dragBarElement = bar;
	    dragBarStartX = e.clientX;
	    dragBarData = rental;
	    
	    // 元の位置と期間情報を保存
	    dragBarOriginalPosition = {
	      left: parseInt(bar.style.left, 10) || 0,
	      width: parseInt(bar.style.width, 10) || 0,
	      timeline: timeline,
	      timelineRect: timeline.getBoundingClientRect(),
	      equipmentId: timeline.dataset.equipment,
	      location: timeline.dataset.location || '',
	      layer: bar.dataset.layer || 0,
	      startDate: rental['借用開始日'],
	      endDate: rental['借用終了日']
	    };
	    
	    // グローバルイベントを追加
	    document.addEventListener('mousemove', onBarDragMove);
	    document.addEventListener('mouseup', onBarDragEnd);
	    
	    // ドラッグアニメーション用のクラスを追加
	    bar.classList.add('dragging');
	  });
	  
	  // 左リサイズハンドルのイベント設定
	  leftResizeHandle.addEventListener('mousedown', function(e) {
	    e.stopPropagation();
	    
	    const timeline = bar.closest('.gantt-timeline');
	    if (!timeline) return;
	    
	    // 貸出情報取得
	    const rentalId = bar.dataset.rentalId;
	    const rental = rentalData.find(item => item['登録日時'] && item['登録日時'].toString() === rentalId);
	    
	    if (!rental) {
	      console.error('貸出情報の取得に失敗しました');
	      return;
	    }
	    
	    // リサイズ開始
	    isResizingBar = true;
	    dragBarMode = 'resize-start';
	    dragBarElement = bar;
	    dragBarStartX = e.clientX;
	    dragBarStartWidth = parseInt(bar.style.width, 10) || 80;
	    dragBarData = rental;
	    
	    // 元の位置を保存
	    dragBarOriginalPosition = {
	      left: parseInt(bar.style.left, 10) || 0,
	      width: parseInt(bar.style.width, 10) || 80,
	      timeline: timeline,
	      timelineRect: timeline.getBoundingClientRect(),
	      equipmentId: timeline.dataset.equipment,
	      location: timeline.dataset.location || '',
	      layer: bar.dataset.layer || 0,
	      startDate: rental['借用開始日'],
	      endDate: rental['借用終了日']
	    };
	    
	    // グローバルイベントを追加
	    document.addEventListener('mousemove', onBarResizeMove);
	    document.addEventListener('mouseup', onBarResizeEnd);
	    
	    // リサイズアニメーション用のクラスを追加
	    bar.classList.add('resizing');
	  });
	  
	  // 右リサイズハンドルのイベント設定
	  rightResizeHandle.addEventListener('mousedown', function(e) {
	    e.stopPropagation();
	    
	    const timeline = bar.closest('.gantt-timeline');
	    if (!timeline) return;
	    
	    // 貸出情報取得
	    const rentalId = bar.dataset.rentalId;
	    const rental = rentalData.find(item => item['登録日時'] && item['登録日時'].toString() === rentalId);
	    
	    if (!rental) {
	      console.error('貸出情報の取得に失敗しました');
	      return;
	    }
	    
	    // リサイズ開始
	    isResizingBar = true;
	    dragBarMode = 'resize-end';
	    dragBarElement = bar;
	    dragBarStartX = e.clientX;
	    dragBarStartWidth = parseInt(bar.style.width, 10) || 80;
	    dragBarData = rental;
	    
	    // 元の位置を保存
	    dragBarOriginalPosition = {
	      left: parseInt(bar.style.left, 10) || 0,
	      width: parseInt(bar.style.width, 10) || 80,
	      timeline: timeline,
	      timelineRect: timeline.getBoundingClientRect(),
	      equipmentId: timeline.dataset.equipment,
	      location: timeline.dataset.location || '',
	      layer: bar.dataset.layer || 0,
	      startDate: rental['借用開始日'],
	      endDate: rental['借用終了日']
	    };
	    
	    // グローバルイベントを追加
	    document.addEventListener('mousemove', onBarResizeMove);
	    document.addEventListener('mouseup', onBarResizeEnd);
	    
	    // リサイズアニメーション用のクラスを追加
	    bar.classList.add('resizing');
	  });
	}
  
  // モバイル用バーイベント設定
  function setupMobileBarEvents(bar, leftHandle, rightHandle, dragHandle, rental) {
    try {
      // ドラッグ開始
      dragHandle.addEventListener('touchstart', function(e) {
        e.stopPropagation();
        
        const timeline = bar.closest('.gantt-timeline');
        if (!timeline) return;
        
        // ドラッグ開始
        isDraggingBar = true;
        dragBarMode = 'move';
        dragBarElement = bar;
        dragBarStartX = e.touches[0].clientX;
        dragBarData = rental;
        
        // 元の位置と期間情報を保存
        dragBarOriginalPosition = {
          left: parseInt(bar.style.left, 10) || 0,
          width: parseInt(bar.style.width, 10) || 0,
          timeline: timeline,
          timelineRect: timeline.getBoundingClientRect(),
          equipmentId: timeline.dataset.equipment,
          location: timeline.dataset.location || '',
          layer: bar.dataset.layer || 0,
          startDate: rental['借用開始日'],
          endDate: rental['借用終了日']
        };
        
        // タッチイベントを追加
        document.addEventListener('touchmove', onBarTouchMove, { passive: false });
        document.addEventListener('touchend', onBarTouchEnd);
        
        // ドラッグアニメーション用のクラスを追加
        bar.classList.add('dragging');
      });
      
      // 左リサイズハンドルのタッチイベント
      leftHandle.addEventListener('touchstart', function(e) {
        e.stopPropagation();
        
        const timeline = bar.closest('.gantt-timeline');
        if (!timeline) return;
        
        // リサイズ開始
        isResizingBar = true;
        dragBarMode = 'resize-start';
        dragBarElement = bar;
        dragBarStartX = e.touches[0].clientX;
        dragBarStartWidth = parseInt(bar.style.width, 10) || 80;
        dragBarData = rental;
        
        // 元の位置を保存
        dragBarOriginalPosition = {
          left: parseInt(bar.style.left, 10) || 0,
          width: parseInt(bar.style.width, 10) || 80,
          timeline: timeline,
          timelineRect: timeline.getBoundingClientRect(),
          equipmentId: timeline.dataset.equipment,
          location: timeline.dataset.location || '',
          layer: bar.dataset.layer || 0,
          startDate: rental['借用開始日'],
          endDate: rental['借用終了日']
        };
        
        // タッチイベントを追加
        document.addEventListener('touchmove', onBarTouchResize, { passive: false });
        document.addEventListener('touchend', onBarTouchResizeEnd);
        
        // リサイズアニメーション用のクラスを追加
        bar.classList.add('resizing');
      });
      
      // 右リサイズハンドルのタッチイベント
      rightHandle.addEventListener('touchstart', function(e) {
        e.stopPropagation();
        
        const timeline = bar.closest('.gantt-timeline');
        if (!timeline) return;
        
        // リサイズ開始
        isResizingBar = true;
        dragBarMode = 'resize-end';
        dragBarElement = bar;
        dragBarStartX = e.touches[0].clientX;
        dragBarStartWidth = parseInt(bar.style.width, 10) || 80;
        dragBarData = rental;
        
        // 元の位置を保存
        dragBarOriginalPosition = {
          left: parseInt(bar.style.left, 10) || 0,
          width: parseInt(bar.style.width, 10) || 80,
          timeline: timeline,
          timelineRect: timeline.getBoundingClientRect(),
          equipmentId: timeline.dataset.equipment,
          location: timeline.dataset.location || '',
          layer: bar.dataset.layer || 0,
          startDate: rental['借用開始日'],
          endDate: rental['借用終了日']
        };
        
        // タッチイベントを追加
        document.addEventListener('touchmove', onBarTouchResize, { passive: false });
        document.addEventListener('touchend', onBarTouchResizeEnd);
        
        // リサイズアニメーション用のクラスを追加
        bar.classList.add('resizing');
      });
    } catch (error) {
      console.error('モバイルバーイベント設定エラー:', error);
    }
  }
  
  // バータッチ移動ハンドラ
  function onBarTouchMove(e) {
    if (!isDraggingBar || !dragBarElement || !dragBarOriginalPosition) return;
    
    e.preventDefault();
    
    const touch = e.touches[0];
    const deltaX = touch.clientX - dragBarStartX;
    const newLeft = Math.max(0, dragBarOriginalPosition.left + deltaX);
    
    // バーの位置のみを更新（幅は維持）
    dragBarElement.style.left = newLeft + 'px';
    
    // ドロップターゲットをハイライト
    const elementsFromPoint = document.elementsFromPoint(touch.clientX, touch.clientY);
    for (const element of elementsFromPoint) {
      if (element.classList.contains('gantt-timeline') && 
          element !== dragBarOriginalPosition.timeline) {
        element.classList.add('drop-target');
        currentDropTarget = element;
        break;
      }
    }
  }

  // バータッチ終了ハンドラ
  function onBarTouchEnd(e) {
    if (!isDraggingBar || !dragBarElement || !dragBarOriginalPosition) return;
    
    // タッチイベント削除
    document.removeEventListener('touchmove', onBarTouchMove);
    document.removeEventListener('touchend', onBarTouchEnd);
    
    // スクロール位置を保存
    saveScrollPosition();
    
    // クラスを削除
    dragBarElement.classList.remove('dragging');
    
    try {
      // ドロップ先のタイムラインを特定
      let targetTimeline = currentDropTarget || dragBarOriginalPosition.timeline;
      let targetEquipmentId = targetTimeline.dataset.equipment;
      let targetLocation = targetTimeline.dataset.location || '';
      
      // 機器IDが無効な場合は元の値を使用
      if (!targetEquipmentId) {
        targetEquipmentId = dragBarOriginalPosition.equipmentId;
        targetLocation = dragBarOriginalPosition.location || '';
      }
      
      // 新しい位置を計算
      const newLeft = parseInt(dragBarElement.style.left, 10);
      // モバイルとPCでセルサイズを変更
      const cellWidth = document.body.classList.contains('mobile-view') ? 
                      (userSettings.mobileCellWidth || 80) : 
                      (userSettings.cellWidth || 80);
      const startIdx = Math.floor(newLeft / cellWidth);
      
      // 日付を取得
      const dayCells = Array.from(targetTimeline.querySelectorAll('.gantt-day'));
      if (startIdx >= dayCells.length || startIdx < 0) {
        resetBarPosition();
        return;
      }
      
      const startDateStr = dayCells[startIdx].dataset.date;
      if (!startDateStr) {
        resetBarPosition();
        return;
      }
      
      // 元の借用期間を計算
      const origStartDate = new Date(dragBarOriginalPosition.startDate);
      const origEndDate = new Date(dragBarOriginalPosition.endDate);
      
      if (isNaN(origStartDate.getTime()) || isNaN(origEndDate.getTime())) {
        resetBarPosition();
        return;
      }
      
      // 日数差を計算
      const daysDiff = Math.round((origEndDate - origStartDate) / (1000 * 60 * 60 * 24));
      
      // 新しい開始日と終了日を計算
      const newStartDate = new Date(startDateStr);
      const newEndDate = new Date(newStartDate);
      newEndDate.setDate(newStartDate.getDate() + daysDiff);
      
      // 表示範囲チェック
      const lastDayCell = dayCells[dayCells.length - 1];
      if (!lastDayCell) {
        resetBarPosition();
        return;
      }
      
      const lastDateStr = lastDayCell.dataset.date;
      if (!lastDateStr) {
        resetBarPosition();
        return;
      }
      
      const lastDate = new Date(lastDateStr);
      if (newEndDate > lastDate) {
        resetBarPosition();
        return;
      }
      
      // 終了日の文字列を取得
      const endDateStr = formatDate(newEndDate);
      
      // 更新処理
      const rentalId = dragBarData['登録日時'].toString();
      
      const oldEquipmentId = dragBarOriginalPosition.equipmentId;
      const oldLocation = dragBarOriginalPosition.location || '';
      
      // 選択中機材を保持
      const keepSelectedEquipment = selectedEquipment;
      const keepSelectedEquipmentWithLocation = selectedEquipmentWithLocation;
      
      // 変更を確認してサーバーに送信
      showRentalUpdateConfirmation(
        rentalId,
        oldEquipmentId,
        targetEquipmentId,
        startDateStr,
        endDateStr,
        oldLocation,
        targetLocation,
        function() {
          // 成功コールバック
          selectedEquipment = keepSelectedEquipment;
          selectedEquipmentWithLocation = keepSelectedEquipmentWithLocation;
        }
      );
    } catch (error) {
      console.error('タッチドラッグ終了エラー:', error);
      resetBarPosition();
    }
    
    // ハイライトを削除
    document.querySelectorAll('.gantt-timeline.drop-target').forEach(el => {
      el.classList.remove('drop-target');
    });
    
    // 変数をリセット
    isDraggingBar = false;
    dragBarElement = null;
    dragBarStartX = 0;
    dragBarOriginalPosition = null;
    dragBarData = null;
    currentDropTarget = null;
  }

  // バータッチリサイズ移動ハンドラ
  function onBarTouchResize(e) {
    if (!isResizingBar || !dragBarElement || !dragBarOriginalPosition) return;
    
    e.preventDefault();
    
    const touch = e.touches[0];
    const deltaX = touch.clientX - dragBarStartX;
    // モバイルとPCでセルサイズを変更
    const cellWidth = document.body.classList.contains('mobile-view') ? 
                    (userSettings.mobileCellWidth || 80) : 
                    (userSettings.cellWidth || 80);
    
    if (dragBarMode === 'resize-start') {
      // 左側のリサイズ
      const maxDelta = dragBarOriginalPosition.width - cellWidth;
      const constrainedDelta = Math.min(maxDelta, Math.max(-dragBarOriginalPosition.left, deltaX));
      
      const newLeft = dragBarOriginalPosition.left + constrainedDelta;
      const newWidth = dragBarOriginalPosition.width - constrainedDelta;
      
      dragBarElement.style.left = newLeft + 'px';
      dragBarElement.style.width = newWidth + 'px';
    } else if (dragBarMode === 'resize-end') {
      // 右側のリサイズ
      const timelineWidth = dragBarOriginalPosition.timelineRect.width;
      const maxRight = timelineWidth;
      const currentRight = dragBarOriginalPosition.left + dragBarOriginalPosition.width;
      
      const maxDelta = maxRight - currentRight;
      const minDelta = cellWidth - dragBarOriginalPosition.width;
      
      const constrainedDelta = Math.min(maxDelta, Math.max(minDelta, deltaX));
      const newWidth = dragBarOriginalPosition.width + constrainedDelta;
      
      dragBarElement.style.width = newWidth + 'px';
    }
  }

  // バータッチリサイズ終了ハンドラ
  function onBarTouchResizeEnd(e) {
    if (!isResizingBar || !dragBarElement || !dragBarOriginalPosition) return;
    
    // タッチイベント削除
    document.removeEventListener('touchmove', onBarTouchResize);
    document.removeEventListener('touchend', onBarTouchResizeEnd);
    
    // スクロール位置を保存
    saveScrollPosition();
    
    // クラスを削除
    dragBarElement.classList.remove('resizing');
    
    try {
      // リサイズ後の詳細を計算
      const newLeft = parseInt(dragBarElement.style.left, 10);
      const width = parseInt(dragBarElement.style.width, 10);
      // モバイルとPCでセルサイズを変更
      const cellWidth = document.body.classList.contains('mobile-view') ? 
                      (userSettings.mobileCellWidth || 80) : 
                      (userSettings.cellWidth || 80);
      
      // 新しい開始インデックスと終了インデックスを計算
      const startIdx = Math.floor(newLeft / cellWidth);
      const endIdx = Math.floor((newLeft + width - 1) / cellWidth);
      
      // 日付を取得
      const timeline = dragBarOriginalPosition.timeline;
      const dayCells = Array.from(timeline.querySelectorAll('.gantt-day'));
      
      if (startIdx >= dayCells.length || endIdx >= dayCells.length || startIdx < 0 || endIdx < 0) {
        resetBarPosition();
        return;
      }
      
      const startDateStr = dayCells[startIdx].dataset.date;
      const endDateStr = dayCells[endIdx].dataset.date;
      
      if (!startDateStr || !endDateStr) {
        resetBarPosition();
        return;
      }
      
      // 貸出データを検索
      const rentalId = dragBarData['登録日時'].toString();
      
      const equipmentId = dragBarOriginalPosition.equipmentId;
      const location = dragBarOriginalPosition.location || '';
      
      // 選択中機材を保持
      const keepSelectedEquipment = selectedEquipment;
      const keepSelectedEquipmentWithLocation = selectedEquipmentWithLocation;
      
      // 変更を確認してサーバーに送信
      showRentalUpdateConfirmation(
        rentalId,
        equipmentId,
        equipmentId,
        startDateStr,
        endDateStr,
        location,
        location,
        function() {
          // 成功コールバック
          selectedEquipment = keepSelectedEquipment;
          selectedEquipmentWithLocation = keepSelectedEquipmentWithLocation;
        }
      );
    } catch (error) {
      console.error('タッチリサイズ終了エラー:', error);
      resetBarPosition();
    }
    
    // 変数をリセット
    isResizingBar = false;
    dragBarElement = null;
    dragBarStartX = 0;
    dragBarStartWidth = 0;
    dragBarOriginalPosition = null;
    dragBarData = null;
    dragBarMode = null;
  }

  // バードラッグのマウス移動ハンドラ
	function onBarDragMove(e) {
	  if (!isDraggingBar || !dragBarElement || !dragBarOriginalPosition) return;
	  
	  e.preventDefault();
	  
	  const deltaX = e.clientX - dragBarStartX;
	  const newLeft = Math.max(0, dragBarOriginalPosition.left + deltaX);
	  
	  // バーの位置のみを更新（幅は維持）
	  dragBarElement.style.left = newLeft + 'px';
	  
	  // ドロップターゲットをハイライト
	  highlightDropTarget(e);
	  
	  // カレンダーの端に近づいたらスクロール
	  const container = document.querySelector('.gantt-container');
	  if (container) {
	    const containerRect = container.getBoundingClientRect();
	    const scrollSpeed = 10;
	    
	    // 右端に近づいたら右にスクロール
	    if (e.clientX > containerRect.right - 50) {
	      container.scrollLeft += scrollSpeed;
	    }
	    
	    // 左端に近づいたら左にスクロール
	    if (e.clientX < containerRect.left + 50) {
	      container.scrollLeft -= scrollSpeed;
	    }
	  }
	}

  // バードラッグの終了ハンドラ
	function onBarDragEnd(e) {
	  if (!isDraggingBar || !dragBarElement || !dragBarOriginalPosition) return;
	  
	  e.preventDefault();
	  
	  // グローバルイベントを削除
	  document.removeEventListener('mousemove', onBarDragMove);
	  document.removeEventListener('mouseup', onBarDragEnd);
	  
	  // クラスを削除
	  dragBarElement.classList.remove('dragging');
	  
	  try {
	    // ドロップ先のタイムラインを特定
	    let targetTimeline = currentDropTarget || dragBarOriginalPosition.timeline;
	    let targetEquipmentId = targetTimeline.dataset.equipment;
	    let targetLocation = targetTimeline.dataset.location || '';
	    
	    // targetEquipmentIdが存在しない場合は元のデータを使用
	    if (!targetEquipmentId) {
	      targetEquipmentId = dragBarOriginalPosition.equipmentId;
	      targetLocation = dragBarOriginalPosition.location || '';
	    }
	    
	    // ドロップ先の詳細を計算
	    const newLeft = parseInt(dragBarElement.style.left, 10);
	    // モバイルとPCでセルサイズを変更
	    const cellWidth = document.body.classList.contains('mobile-view') ? 
	                    (userSettings.mobileCellWidth || 80) : 
	                    (userSettings.cellWidth || 80);
	    
	    // 新しい開始インデックスを計算
	    const startIdx = Math.floor(newLeft / cellWidth);
	    
	    // 日付配列から対応する日付を取得
	    const dayCells = Array.from(targetTimeline.querySelectorAll('.gantt-day'));
	    if (startIdx >= dayCells.length || startIdx < 0) {
	      // 範囲外ならキャンセル
	      resetBarPosition();
	      return;
	    }
	    
	    const startDateStr = dayCells[startIdx].dataset.date;
	    
	    if (!startDateStr) {
	      // 日付が取得できなければキャンセル
	      resetBarPosition();
	      return;
	    }
	    
	    // 元の借用日数を計算
	    const origStartDate = new Date(dragBarOriginalPosition.startDate);
	    const origEndDate = new Date(dragBarOriginalPosition.endDate);
	    
	    // 日付が有効かチェック
	    if (isNaN(origStartDate.getTime()) || isNaN(origEndDate.getTime())) {
	      console.error('無効な元の日付', dragBarOriginalPosition.startDate, dragBarOriginalPosition.endDate);
	      resetBarPosition();
	      return;
	    }
	    
	    // 日数差を計算（ミリ秒→日に変換、端数を四捨五入）
	    const daysDiff = Math.round((origEndDate - origStartDate) / (1000 * 60 * 60 * 24));
	    console.log(`元の借用期間: ${daysDiff}日間`);
	    
	    // 新しい開始日を取得
	    const newStartDate = new Date(startDateStr);
	    
	    // 新しい終了日を計算（開始日 + 元の日数差）
	    const newEndDate = new Date(newStartDate);
	    newEndDate.setDate(newStartDate.getDate() + daysDiff);
	    
	    // 終了日が表示範囲内かチェック
	    const lastDayCell = dayCells[dayCells.length - 1];
	    if (!lastDayCell) {
	      console.error('日付セルが見つかりません');
	      resetBarPosition();
	      return;
	    }
	    
	    const lastDateStr = lastDayCell.dataset.date;
	    if (!lastDateStr) {
	      console.error('最終日の日付が取得できません');
	      resetBarPosition();
	      return;
	    }
	    
	    const lastDate = new Date(lastDateStr);
	    
	    if (newEndDate > lastDate) {
	      alert('表示範囲外の日付になるため変更できません');
	      resetBarPosition();
	      return;
	    }
	    
	    // 終了日の文字列を取得
	    const endDateStr = formatDate(newEndDate);
	    
	    console.log(`新しい借用期間: ${startDateStr} ～ ${endDateStr}`);
	    
	    // 変更前の機材IDと定置場所を記録
	    const oldEquipmentId = dragBarOriginalPosition.equipmentId;
	    const oldLocation = dragBarOriginalPosition.location || '';
	    
	    // スクロール位置を保存（元の位置を維持するため）
	    const container = document.querySelector('.gantt-container');
	    const originalScrollPosition = {
	      top: container ? container.scrollTop : 0,
	      left: container ? container.scrollLeft : 0
	    };
	    
	    // 変更内容の確認ダイアログ
	    showRentalUpdateConfirmation(
	      dragBarElement.dataset.rentalId,
	      oldEquipmentId,
	      targetEquipmentId,
	      startDateStr,
	      endDateStr,
	      oldLocation,
	      targetLocation,
	      function() {
	        // 成功時のコールバック - スクロール位置を復元
	        if (container) {
	          container.scrollTop = originalScrollPosition.top;
	          container.scrollLeft = originalScrollPosition.left;
	        }
	      }
	    );
	  } catch (error) {
	    console.error('ドラッグ終了処理エラー:', error);
	    resetBarPosition();
	  }
	  
	  // ハイライトを削除
	  removeDropTargetHighlight();
	  
	  // ドラッグ変数をリセット
	  isDraggingBar = false;
	  dragBarElement = null;
	  dragBarStartX = 0;
	  dragBarOriginalPosition = null;
	  dragBarData = null;
	  currentDropTarget = null;
	}

  // バーリサイズのマウス移動ハンドラ
  function onBarResizeMove(e) {
    if (!isResizingBar || !dragBarElement || !dragBarOriginalPosition) return;
    
    e.preventDefault();
    
    const deltaX = e.clientX - dragBarStartX;
    // モバイルとPCでセルサイズを変更
    const cellWidth = document.body.classList.contains('mobile-view') ? 
                    (userSettings.mobileCellWidth || 80) : 
                    (userSettings.cellWidth || 80);
    
    if (dragBarMode === 'resize-start') {
      // 左側のリサイズ（開始日を変更）
      const maxDelta = dragBarOriginalPosition.width - cellWidth; // 最低1セルは残す
      const constrainedDelta = Math.min(maxDelta, Math.max(-dragBarOriginalPosition.left, deltaX));
      
      const newLeft = dragBarOriginalPosition.left + constrainedDelta;
      const newWidth = dragBarOriginalPosition.width - constrainedDelta;
      
      dragBarElement.style.left = newLeft + 'px';
      dragBarElement.style.width = newWidth + 'px';
    } else if (dragBarMode === 'resize-end') {
      // 右側のリサイズ（終了日を変更）
      const timelineWidth = dragBarOriginalPosition.timelineRect.width;
      const maxRight = timelineWidth;
      const currentRight = dragBarOriginalPosition.left + dragBarOriginalPosition.width;
      
      const maxDelta = maxRight - currentRight;
      const minDelta = cellWidth - dragBarOriginalPosition.width; // 最低1セルは残す
      
      const constrainedDelta = Math.min(maxDelta, Math.max(minDelta, deltaX));
      const newWidth = dragBarOriginalPosition.width + constrainedDelta;
      
      dragBarElement.style.width = newWidth + 'px';
    }
  }

  // バーリサイズの終了ハンドラ
	function onBarResizeEnd(e) {
	  if (!isResizingBar || !dragBarElement || !dragBarOriginalPosition) return;
	  
	  e.preventDefault();
	  
	  // グローバルイベントを削除
	  document.removeEventListener('mousemove', onBarResizeMove);
	  document.removeEventListener('mouseup', onBarResizeEnd);
	  
	  // クラスを削除
	  dragBarElement.classList.remove('resizing');
	  
	  try {
	    // リサイズ後の詳細を計算
	    const newLeft = parseInt(dragBarElement.style.left, 10);
	    const width = parseInt(dragBarElement.style.width, 10);
	    // モバイルとPCでセルサイズを変更
	    const cellWidth = document.body.classList.contains('mobile-view') ? 
	                    (userSettings.mobileCellWidth || 80) : 
	                    (userSettings.cellWidth || 80);
	    
	    // 新しい開始インデックスと終了インデックスを計算
	    const startIdx = Math.floor(newLeft / cellWidth);
	    const endIdx = Math.floor((newLeft + width - 1) / cellWidth);
	    
	    // 日付配列から対応する日付を取得
	    const timeline = dragBarOriginalPosition.timeline;
	    const dayCells = Array.from(timeline.querySelectorAll('.gantt-day'));
	    
	    if (startIdx >= dayCells.length || endIdx >= dayCells.length || startIdx < 0 || endIdx < 0) {
	      // 範囲外ならキャンセル
	      resetBarPosition();
	      return;
	    }
	    
	    const startDateStr = dayCells[startIdx].dataset.date;
	    const endDateStr = dayCells[endIdx].dataset.date;
	    
	    if (!startDateStr || !endDateStr) {
	      // 日付が取得できなければキャンセル
	      resetBarPosition();
	      return;
	    }
	    
	    // データの準備
	    const equipmentId = dragBarOriginalPosition.equipmentId;
	    const location = dragBarOriginalPosition.location || '';
	    const rentalId = dragBarElement.dataset.rentalId;
	    
	    // スクロール位置を保存（元の位置を維持するため）
	    const container = document.querySelector('.gantt-container');
	    const originalScrollPosition = {
	      top: container ? container.scrollTop : 0,
	      left: container ? container.scrollLeft : 0
	    };
	    
	    // 変更内容の確認ダイアログ
	    showRentalUpdateConfirmation(
	      rentalId, 
	      equipmentId, 
	      equipmentId, 
	      startDateStr, 
	      endDateStr, 
	      location, 
	      location,
	      function() {
	        // 成功時のコールバック - スクロール位置を復元
	        if (container) {
	          container.scrollTop = originalScrollPosition.top;
	          container.scrollLeft = originalScrollPosition.left;
	        }
	      }
	    );
	  } catch (error) {
	    console.error('リサイズ終了処理エラー:', error);
	    resetBarPosition();
	  }
	  
	  // リサイズ変数をリセット
	  isResizingBar = false;
	  dragBarElement = null;
	  dragBarStartX = 0;
	  dragBarStartWidth = 0;
	  dragBarOriginalPosition = null;
	  dragBarData = null;
	  dragBarMode = null;
	}

	// スクロール位置を保存する関数
	function saveScrollPosition() {
	  const container = document.querySelector('.gantt-container');
	  if (container) {
	    savedScrollPosition = {
	      top: container.scrollTop,
	      left: container.scrollLeft
	    };
	  }
	}

  // バーの位置をリセットする関数
  function resetBarPosition() {
    if (!dragBarElement || !dragBarOriginalPosition) return;
    
    dragBarElement.style.left = dragBarOriginalPosition.left + 'px';
    dragBarElement.style.width = dragBarOriginalPosition.width + 'px';
  }

  // ドロップターゲットをハイライトする関数
  function highlightDropTarget(e) {
    // すべてのハイライトをクリア
    removeDropTargetHighlight();
    
    // マウス位置の要素を取得
    const elementsFromPoint = document.elementsFromPoint(e.clientX, e.clientY);
    
    // タイムラインを検索
    for (const element of elementsFromPoint) {
      if (element.classList.contains('gantt-timeline')) {
        // 現在のタイムラインと異なる場合のみハイライト
        if (element !== dragBarOriginalPosition.timeline) {
          element.classList.add('drop-target');
          currentDropTarget = element;
        }
        break;
      }
    }
  }

  // ドロップターゲットのハイライトを削除する関数
  function removeDropTargetHighlight() {
    document.querySelectorAll('.gantt-timeline.drop-target').forEach(el => {
      el.classList.remove('drop-target');
    });
    currentDropTarget = null;
  }
  
  // 貸出変更確認ダイアログを表示する関数
  function showRentalUpdateConfirmation(rentalId, oldEquipmentId, newEquipmentId, startDateStr, endDateStr, oldLocation, newLocation, successCallback) {
    // 機材情報の取得
    const oldEquipment = equipmentList.find(item => String(item['機器管理番号']) === String(oldEquipmentId));
    const newEquipment = equipmentList.find(item => String(item['機器管理番号']) === String(newEquipmentId));
    
    if (!oldEquipment || !newEquipment) {
      alert('機材情報の取得に失敗しました');
      resetBarPosition();
      return;
    }
    
    // 貸出情報の取得
    const rental = rentalData.find(item => item['登録日時'] && item['登録日時'].toString() === rentalId);
    
    if (!rental) {
      alert('貸出情報の取得に失敗しました');
      resetBarPosition();
      return;
    }
    
    // 機材変更の場合は台数制限の確認
    if (oldEquipmentId !== newEquipmentId || oldLocation !== newLocation) {
      // 新しい機材の総台数を確認
      const newEquipItems = equipmentList.filter(item => 
        String(item['機器管理番号']) === String(newEquipmentId) && 
        String(item['定置場所'] || '') === String(newLocation)
      );
      
      const totalQuantity = newEquipItems.reduce((sum, item) => sum + (parseInt(item['総台数']) || 0), 0);
      const requestedQuantity = parseInt(rental['数量']) || 1;
      
      if (requestedQuantity > totalQuantity) {
        alert(`${newEquipment['機器名称']}(${newLocation})の総台数(${totalQuantity}台)を超えています。変更する場合は貸出数量を調整してください。`);
        resetBarPosition();
        return;
      }
    }
    
    // 日付の妥当性チェック
    const startDate = new Date(startDateStr);
    const endDate = new Date(endDateStr);
    
    if (startDate > endDate) {
      alert('開始日は終了日よりも前の日付にしてください');
      resetBarPosition();
      return;
    }
    
    // 貸出可能性のチェック
    if (!checkAvailabilityForUpdate(newEquipmentId, startDateStr, endDateStr, rental['数量'], rentalId, newLocation)) {
      resetBarPosition();
      return;
    }
    
    // 確認ダイアログの表示有無を確認
    if (userSettings.showConfirmDialog) {
      // 確認メッセージを構築
      let message = '以下の内容で貸出情報を更新しますか？\n\n';
      
      if (oldEquipmentId !== newEquipmentId) {
        message += `機材: ${oldEquipment['機器名称']} → ${newEquipment['機器名称']}\n`;
      }
      
      if (oldLocation !== newLocation) {
        message += `定置場所: ${oldLocation || '未設定'} → ${newLocation || '未設定'}\n`;
      }
      
      message += `期間: ${formatDate(new Date(rental['借用開始日']))} ～ ${formatDate(new Date(rental['借用終了日']))}\n`;
      message += `　 → ${startDateStr} ～ ${endDateStr}\n`;
      message += `数量: ${rental['数量']}台\n`;
      message += `使用場所: ${rental['使用場所']}\n`;
      
      // 確認ダイアログを表示
      if (confirm(message)) {
        // 更新処理を実行
        updateRental(rentalId, newEquipmentId, newEquipment['機器名称'], startDateStr, endDateStr, rental['数量'], rental['使用場所'], newLocation, successCallback);
      } else {
        // キャンセルの場合は元の位置に戻す
        resetBarPosition();
      }
    } else {
      // 確認なしで直接更新
      updateRental(rentalId, newEquipmentId, newEquipment['機器名称'], startDateStr, endDateStr, rental['数量'], rental['使用場所'], newLocation, successCallback);
    }
  }

  // 貸出更新時の貸出可能性チェック（重複・台数チェック）
  function checkAvailabilityForUpdate(equipmentId, startDate, endDate, requestedQuantity, excludeRentalId, location) {
    try {
      // 機材情報取得 - 機器管理番号と定置場所で検索
      const equipItems = equipmentList.filter(item => 
        String(item['機器管理番号']) === String(equipmentId) &&
        String(item['定置場所'] || '') === String(location || '')
      );
      if (equipItems.length === 0) {
        alert('機材情報の取得に失敗しました');
        return false;
      }
      
      // 指定した定置場所の機材の総台数を合計
      const totalQuantity = equipItems.reduce((sum, item) => sum + (parseInt(item['総台数']) || 0), 0);
      
      // 日付範囲
      const start = new Date(startDate);
      const end = new Date(endDate);
      
      start.setHours(0, 0, 0, 0);
      end.setHours(0, 0, 0, 0);
      
      // 各日にちで利用可能数チェック
      let currentDate = new Date(start);
      let availabilityIssues = [];
      
      while (currentDate <= end) {
        const dateStr = formatDate(currentDate);
        let rentedQuantity = 0;
        
        // この日付で貸出中の数量を計算
        rentalData.forEach(rental => {
          if (!rental) return;
          
          // 自分自身の貸出は除外
          if (rental['登録日時'] && rental['登録日時'].toString() === excludeRentalId) {
            return;
          }
          
          // この機材の貸出（機器管理番号 AND 定置場所が一致する）
          if (String(rental['機器管理番号']) === String(equipmentId) && 
              String(rental['貸出元'] || '') === String(location || '')) {
              
            // ステータスが返却済みの場合はスキップ
            if (rental['ステータス'] === '返却済み') return;
            
            // 返却日がある場合も返却済みとみなしてスキップ
            if (rental['返却日'] && rental['ステータス'] === '返却済み') return;
            
            // 日付型変換
            let rentalStart = parseDate(rental['借用開始日']);
            let rentalEnd = parseDate(rental['借用終了日']);
            
            // 日付有効性チェック
            if (!rentalStart || !rentalEnd) {
              return;
            }
            
            // 日付範囲チェック
            if (rentalStart <= currentDate && rentalEnd >= currentDate) {
              rentedQuantity += parseInt(rental['数量']) || 0;
            }
          }
        });
        
        // 利用可能数チェック
        const availableQuantity = totalQuantity - rentedQuantity;
        
        if (requestedQuantity > availableQuantity) {
          availabilityIssues.push({
            date: dateStr,
            available: availableQuantity,
            requested: requestedQuantity
          });
        }
        
        // 次の日へ
        currentDate.setDate(currentDate.getDate() + 1);
      }
      
      // 利用可能性の問題がある場合
      if (availabilityIssues.length > 0) {
        let message = '以下の日付で貸出可能台数を超えています：\n\n';
        
        availabilityIssues.forEach(issue => {
          message += `${issue.date}: 利用可能台数 ${issue.available}台（要求: ${issue.requested}台）\n`;
        });
        
        message += '\n貸出数量を調整するか、日付を変更してください。';
        
        alert(message);
        return false;
      }
      
      return true;
    } catch (error) {
      console.error('貸出可能チェックエラー:', error);
      alert('貸出可能性のチェックに失敗しました: ' + error);
      return false;
    }
  }
  
  // 貸出データを更新する関数
  function updateRental(rentalId, equipmentId, equipmentName, startDate, endDate, quantity, location, sourceLocation, successCallback) {
	  try {
	    console.log('貸出更新開始');
	    
	    // スクロール位置を保存
	    const ganttContainer = document.querySelector('.gantt-container');
	    const savedScrollLeft = ganttContainer ? ganttContainer.scrollLeft : 0;
	    const savedScrollTop = ganttContainer ? ganttContainer.scrollTop : 0;
	    
	    // データ準備
	    const data = {
	      rentalId: rentalId,
	      equipmentId: equipmentId,
	      equipmentName: equipmentName,
	      startDate: startDate,
	      endDate: endDate,
	      quantity: quantity,
	      location: location,
	      sourceLocation: sourceLocation // 貸出元の定置場所
	    };
	    
	    console.log('送信データ:', data);
	    
	    // 更新API実行
	    showLoading();
	    google.script.run
	      .withSuccessHandler(function(response) {
	        hideLoading();
	        
	        if (response && response.success) {
	          // 成功処理
	          console.log('更新成功:', response);
	          
	          // Undoスタック追加
	          undoStack.push({
	            action: 'undoUpdate',
	            id: rentalId,
	            previousData: dragBarData
	          });
	          
	          // Undoボタン有効化
	          const undoButton = document.getElementById('undo-button');
	          if (undoButton) undoButton.disabled = false;
	          
	          // データ再読み込み
	          google.script.run
	            .withSuccessHandler(function(rentalDataResponse) {
	              if (rentalDataResponse && Array.isArray(rentalDataResponse)) {
	                // 日付文字列をDateオブジェクトに変換して保存
	                rentalData = rentalDataResponse.map(item => {
	                  Object.keys(item).forEach(key => {
	                    if (key === '借用開始日' || key === '借用終了日' || key === '登録日時' || key === '返却日') {
	                      if (item[key] && typeof item[key] === 'string') {
	                        item[key] = new Date(item[key]);
	                      }
	                    }
	                  });
	                  
	                  if (!item['ステータス']) {
	                    item['ステータス'] = item['返却日'] ? '返却済み' : '貸出中';
	                  }
	                  
	                  return item;
	                });
	              } else {
	                rentalData = [];
	              }
	              
	              // スクロール位置が変わらないようにフラグをセット
	              skipScrollToSelectedEquipment = true;
	              
	              // ガントチャート更新
	              updateGanttChart();
	              
	              // スクロール位置を復元
	              setTimeout(() => {
	                if (ganttContainer) {
	                  ganttContainer.scrollLeft = savedScrollLeft;
	                  ganttContainer.scrollTop = savedScrollTop;
	                }
	                
	                // フラグをリセット
	                skipScrollToSelectedEquipment = false;
	                
	                // 成功時のコールバックがあれば実行
	                if (typeof successCallback === 'function') {
	                  successCallback();
	                }
	              }, 100);
	            })
	            .withFailureHandler(function(error) {
	              console.error('貸出データ再取得失敗:', error);
	              
	              // スクロール位置が変わらないようにフラグをセット
	              skipScrollToSelectedEquipment = true;
	              
	              // ガントチャート更新
	              updateGanttChart();
	              
	              // スクロール位置を復元
	              setTimeout(() => {
	                if (ganttContainer) {
	                  ganttContainer.scrollLeft = savedScrollLeft;
	                  ganttContainer.scrollTop = savedScrollTop;
	                }
	                
	                // フラグをリセット
	                skipScrollToSelectedEquipment = false;
	                
	                // 失敗時もコールバックを実行
	                if (typeof successCallback === 'function') {
	                  successCallback();
	                }
	              }, 100);
	            })
	            .getRentalData();
	          
	          // 成功メッセージ
	          if (userSettings.showConfirmDialog) {
	            alert('貸出情報を更新しました');
	          }
	        } else {
	          // 失敗処理
	          console.error('更新失敗:', response);
	          resetBarPosition();
	          alert('貸出更新に失敗しました: ' + (response ? response.error : '不明なエラー'));
	        }
	      })
	      .withFailureHandler(function(error) {
	        hideLoading();
	        console.error('更新エラー:', error);
	        resetBarPosition();
	        alert('貸出更新に失敗しました: ' + error);
	      })
	      .updateRental(data);
	  } catch (error) {
	    console.error('貸出更新エラー:', error);
	    resetBarPosition();
	    alert('貸出更新処理でエラーが発生しました: ' + error);
	  }
	}
  
  // スクロール位置を保存する関数
  function saveScrollPosition() {
    const container = document.querySelector('.gantt-container');
    if (container) {
      savedScrollPosition = {
        top: container.scrollTop,
        left: container.scrollLeft
      };
    }
  }
  
  // スクロール位置を復元する関数
	function restoreScrollPosition() {
	  const container = document.querySelector('.gantt-container');
	  if (container && savedScrollPosition) {
	    container.scrollTop = savedScrollPosition.top;
	    container.scrollLeft = savedScrollPosition.left;
	  }
	}
  
  

  // 文字サイズの更新とそれに応じたレイアウト調整
	function updateFontSize(fontSize) {
	  // フォントサイズをルート要素に適用
	  document.documentElement.style.fontSize = fontSize + 'px';
	  
	  // PC・モバイル共通の文字サイズ調整
	  const elements = document.querySelectorAll('.gantt-item, .equipment-name, .equipment-location, .equipment-stock, .equipment-detail');
	  elements.forEach(el => {
	    el.style.fontSize = `${fontSize}px`;
	  });
	  
	  // 日付ヘッダーのフォントサイズ調整
	  document.querySelectorAll('.gantt-date').forEach(el => {
	    el.style.fontSize = `${Math.max(10, parseInt(fontSize) * 0.9)}px`;
	  });
	  
	  // レンタルバーのフォントサイズ調整
	  document.querySelectorAll('.rental-bar').forEach(el => {
	    el.style.fontSize = `${parseInt(fontSize) * 0.9}px`;
	    
	    // バーの高さも調整
	    if (document.body.classList.contains('mobile-view')) {
	      // モバイル表示の場合はより大きく
	      const newHeight = Math.max(30, parseInt(fontSize) * 2);
	      el.style.height = `${newHeight}px`;
	      el.style.lineHeight = `${newHeight - 10}px`;
	    } else {
	      // PC表示の場合は適度なサイズに
	      const newHeight = Math.max(25, parseInt(fontSize) * 1.5);
	      el.style.height = `${newHeight}px`;
	      el.style.lineHeight = `${newHeight - 10}px`;
	    }
	  });
	  
	  // ガントチャートを再描画（レイアウト修正のため）
	  setTimeout(() => {
	    const ganttContainer = document.querySelector('.gantt-container');
	    if (ganttContainer) {
	      // スクロール位置を保存
	      const savedScrollLeft = ganttContainer.scrollLeft;
	      const savedScrollTop = ganttContainer.scrollTop;
	      
	      // 再描画
	      updateGanttChart();
	      
	      // スクロール位置を復元
	      setTimeout(() => {
	        ganttContainer.scrollLeft = savedScrollLeft;
	        ganttContainer.scrollTop = savedScrollTop;
	      }, 100);
	    }
	  }, 200);
	}

	// モバイルサポートの設定
function setupMobileSupport() {
  try {
    console.log('モバイルサポート設定開始');
    
    // ユーザーエージェントでモバイル判定
    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // 画面サイズでもモバイル判定（768px以下）
    const isSmallScreen = window.innerWidth <= 768;
    
    // ローカルストレージからモバイル設定を取得
    const storedMobileView = localStorage.getItem('mobileView');
    
    // モバイルデバイスまたは小さい画面またはストレージ設定がある場合
    if (isMobileDevice || isSmallScreen || storedMobileView === 'true') {
      // モバイル表示クラスを追加
      document.body.classList.add('mobile-view');
      
      // 設定を保存
      localStorage.setItem('mobileView', 'true');
      
      // モバイル用のセル幅を設定
      if (!userSettings.mobileCellWidth) {
        userSettings.mobileCellWidth = 80;
      }
      
      // モバイル用のカスタムスタイルを追加
      addCustomMobileStyles();
      
      // モバイル向けイベント設定
      setupMobileEvents();
      
      console.log('モバイル表示モードを適用しました');
    } else {
      document.body.classList.remove('mobile-view');
      localStorage.setItem('mobileView', 'false');
      console.log('PC表示モードを適用しました');
    }
    
    // PC/モバイル表示切り替えボタンのイベント設定
    document.getElementById('toggle-pc-view')?.addEventListener('click', function() {
      document.body.classList.remove('mobile-view');
      updateMobileSettings();
      // ガントチャート更新
      updateGanttChart();
    });
    
    document.getElementById('toggle-mobile-view')?.addEventListener('click', function() {
      document.body.classList.add('mobile-view');
      updateMobileSettings();
      // ガントチャート更新
      updateGanttChart();
    });
    
    document.getElementById('return-to-desktop')?.addEventListener('click', function() {
      document.body.classList.remove('mobile-view');
      updateMobileSettings();
      // ガントチャート更新
      updateGanttChart();
    });
    
    console.log('モバイルサポート設定完了');
  } catch (error) {
    console.error('モバイルサポート設定エラー:', error);
  }
}

  // モバイル設定を更新
function updateMobileSettings() {
  try {
    const isMobileView = document.body.classList.contains('mobile-view');
    localStorage.setItem('mobileView', isMobileView ? 'true' : 'false');
    
    if (isMobileView && !addedMobileStyles) {
      addCustomMobileStyles();
      addedMobileStyles = true;
    }
    
    console.log(`表示モードを${isMobileView ? 'モバイル' : 'PC'}に変更しました`);
  } catch (error) {
    console.error('モバイル設定更新エラー:', error);
  }
}

  // 長押し選択モードの設定
  function setupLongPressSelection() {
    try {
      const ganttContainer = document.querySelector('.gantt-container');
      if (!ganttContainer) return;
      
      // 長押し判定用変数
      let longPressTimer = null;
      let isLongPressing = false;
      let longPressStartElement = null;
      let longPressStartDate = null;
      let longPressEndDate = null;
      
      // タッチ開始
      ganttContainer.addEventListener('touchstart', function(e) {
        // 既にドラッグ操作中は何もしない
        if (isDraggingBar || isResizingBar) return;
        
        // 貸出バーの場合は通常のクリックイベントを処理
        if (e.target.classList.contains('rental-bar') || 
            e.target.closest('.rental-bar')) {
          return;
        }
        
        // 機材情報部分なら通常スクロール
        if (e.target.closest('.gantt-item')) {
          return;
        }
        
        const touch = e.touches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        
        // ガントチャートのセルだけを対象にする
        if (element && element.classList.contains('gantt-day')) {
          // 長押し判定用タイマー
          longPressTimer = setTimeout(function() {
            // バイブレーション（利用可能な場合）
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            
            isLongPressing = true;
            longPressStartElement = element;
            longPressStartDate = element.dataset.date;
            longPressEndDate = element.dataset.date;
            
            // 最初のセルをハイライト
            element.classList.add('touch-selection');
          }, 500); // 500ms長押しで選択モード開始
        }
      });
      
      // タッチ移動
      ganttContainer.addEventListener('touchmove', function(e) {
        // 長押し中でない場合は通常スクロール
        if (!isLongPressing) return;
        
        e.preventDefault(); // スクロールを防止
        
        const touch = e.touches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        
        // ガントチャートのセルだけを対象にする
        if (element && element.classList.contains('gantt-day')) {
          // 現在の日付を取得
          const currentDate = element.dataset.date;
          
          if (currentDate) {
            // 終了日を更新
            longPressEndDate = currentDate;
            
            // 同じタイムラインのセルを取得
            const timeline = element.closest('.gantt-timeline');
            if (timeline) {
              const dayCells = Array.from(timeline.querySelectorAll('.gantt-day'));
              
              // 全てのハイライトを消去
              dayCells.forEach(cell => {
                cell.classList.remove('touch-selection');
              });
              
              // 開始日と終了日を日付オブジェクトに変換
              const startDate = new Date(longPressStartDate);
              const endDate = new Date(longPressEndDate);
              
              // 日付順に並び替え
              const minDate = startDate < endDate ? startDate : endDate;
              const maxDate = startDate > endDate ? startDate : endDate;
              
              // 範囲内のセルをハイライト
              dayCells.forEach(cell => {
                if (!cell.dataset.date) return;
                
                const cellDate = new Date(cell.dataset.date);
                if (cellDate >= minDate && cellDate <= maxDate) {
                  cell.classList.add('touch-selection');
                }
              });
            }
          }
        }
      }, { passive: false });
      
      // タッチ終了
      ganttContainer.addEventListener('touchend', function(e) {
        // 長押しタイマーをクリア
        clearTimeout(longPressTimer);
        
        // 長押し中でない場合は何もしない
        if (!isLongPressing) return;
        
        try {
          // 開始日と終了日を取得
          if (longPressStartDate && longPressEndDate) {
            const startDate = new Date(longPressStartDate);
            const endDate = new Date(longPressEndDate);
            
            // 日付順に並び替え
            const fromDate = startDate <= endDate ? longPressStartDate : longPressEndDate;
            const toDate = startDate > endDate ? longPressStartDate : longPressEndDate;
            
            // 機材情報を取得
            const timeline = longPressStartElement.closest('.gantt-timeline');
            if (timeline) {
              const equipmentId = timeline.dataset.equipment;
              const location = timeline.dataset.location || '';
              
              // ハイライトを削除
              const dayCells = Array.from(timeline.querySelectorAll('.gantt-day'));
              dayCells.forEach(cell => {
                cell.classList.remove('touch-selection');
              });
              
              // 貸出モーダルを表示
              if (fromDate && toDate && equipmentId) {
                showRentalModal(equipmentId, fromDate, toDate, location);
              }
            }
          }
        } catch (error) {
          console.error('長押し選択終了エラー:', error);
        }
        
        // 長押し状態をリセット
        isLongPressing = false;
        longPressStartElement = null;
        longPressStartDate = null;
        longPressEndDate = null;
      });
      
      // キャンセル時
      ganttContainer.addEventListener('touchcancel', function(e) {
        clearTimeout(longPressTimer);
        
        // ハイライトを削除
        document.querySelectorAll('.touch-selection').forEach(cell => {
          cell.classList.remove('touch-selection');
        });
        
        // 状態をリセット
        isLongPressing = false;
        longPressStartElement = null;
        longPressStartDate = null;
        longPressEndDate = null;
      });
    } catch (error) {
      console.error('長押し選択モード設定エラー:', error);
    }
  }
  
  /**
 * モバイル版カレンダースワイプ修正
 * 以下の問題を解決するための修正コード
 * 1. カレンダー部左から右にスワイプすると、機材名も一緒に動いて元の位置に戻る問題
 * 2. セル部分をスワイプすると日付の動きが遅い問題
 * 3. 日付部分をスワイプすると機材名が左に消えて日付欄だけが動く問題
 */

// カレンダースワイプ関数を完全に修正
function setupCalendarSwipe() {
  try {
    console.log('モバイルスワイプ設定開始');
    
    const container = document.querySelector('.gantt-container');
    if (!container) return;
    
    // スワイプ用変数
    let touchStartX = 0;
    let touchCurrentX = 0;
    let isDragging = false;
    let initialScrollLeft = 0;
    let startTime = 0;
    let dateHeaders = null;
    let allTimelines = null;
    
    // 対象となる要素のセレクタ
    const swipeableSelectors = [
      '.gantt-dates',
      '.gantt-date',
      '.gantt-timeline',
      '.gantt-day',
      '#date-headers'
    ];
    
    // タッチイベント開始
    container.addEventListener('touchstart', function(e) {
      // 貸出バーやボタンなどの操作要素は無視
      if (e.target.closest('.rental-bar, .return-button, button, select')) {
        return;
      }
      
      // ターゲット要素をチェック - スワイプ対象の要素かどうか
      let targetMatches = false;
      for (const selector of swipeableSelectors) {
        if (e.target.closest(selector)) {
          targetMatches = true;
          break;
        }
      }
      
      if (!targetMatches) return;
      
      e.preventDefault(); // デフォルト動作を防止
      
      // 全ての日付ヘッダーとタイムラインを取得
      dateHeaders = document.querySelector('#date-headers');
      allTimelines = document.querySelectorAll('.gantt-timeline');
      
      if (!dateHeaders) return;
      
      // 開始位置を記録
      touchStartX = e.touches[0].clientX;
      touchCurrentX = touchStartX;
      initialScrollLeft = dateHeaders.scrollLeft;
      startTime = Date.now();
      
      // スワイプ開始
      isDragging = true;
      isSwiping = true; // グローバル変数フラグを設定
      
      // スワイプスタイルをボディに追加
      document.body.classList.add('swiping');
      
      // 機材名セルを固定するためのクラスを追加
      const ganttItems = document.querySelectorAll('.gantt-item');
      ganttItems.forEach(item => {
        item.classList.add('swipe-fixed');
      });
    }, { passive: false });
    
    // タッチ移動
    container.addEventListener('touchmove', function(e) {
      if (!isDragging || !dateHeaders) return;
      
      touchCurrentX = e.touches[0].clientX;
      const diff = touchStartX - touchCurrentX;
      
      // スクロール位置を更新（左右両方向に）
      dateHeaders.scrollLeft = initialScrollLeft + diff;
      
      // すべてのタイムラインも同期
      if (allTimelines) {
        allTimelines.forEach(timeline => {
          timeline.scrollLeft = dateHeaders.scrollLeft;
        });
      }
    }, { passive: true });
    
    // タッチ終了
    container.addEventListener('touchend', function(e) {
      if (!isDragging) return;
      
      // スワイプ終了
      isDragging = false;
      
      // スワイプ終了処理
      const endTime = Date.now();
      const duration = endTime - startTime;
      const diff = touchStartX - touchCurrentX;
      
      // 慣性スクロール
      if (Math.abs(diff) > 50 && duration < 300) {
        // 速いスワイプならば慣性スクロール
        const velocity = diff / duration;
        const inertiaDistance = velocity * 300; // 慣性距離
        
        if (dateHeaders) {
          // 慣性スクロールをスムーズに適用
          dateHeaders.style.scrollBehavior = 'smooth';
          dateHeaders.scrollLeft = initialScrollLeft + diff + inertiaDistance;
          
          // すべてのタイムラインにも適用
          if (allTimelines) {
            allTimelines.forEach(timeline => {
              timeline.style.scrollBehavior = 'smooth';
              timeline.scrollLeft = dateHeaders.scrollLeft;
            });
          }
          
          // スクロール動作を元に戻す
          setTimeout(() => {
            dateHeaders.style.scrollBehavior = '';
            if (allTimelines) {
              allTimelines.forEach(timeline => {
                timeline.style.scrollBehavior = '';
              });
            }
          }, 300);
        }
      }
      
      // スワイプスタイルを削除
      document.body.classList.remove('swiping');
      
      // 機材名セルの固定を解除
      const ganttItems = document.querySelectorAll('.gantt-item');
      ganttItems.forEach(item => {
        item.classList.remove('swipe-fixed');
      });
      
      // スワイプ終了時刻を記録
      swipeEndTime = Date.now();
      // 遅延してスワイプフラグをリセット
      setTimeout(() => {
        isSwiping = false;
      }, userSettings.swipeDelay || 500);
    }, { passive: true });
    
    console.log('モバイルスワイプ設定完了');
  } catch (error) {
    console.error('モバイルスワイプ設定エラー:', error);
  }
}

  // 4. スクロール同期関数（すべてのタイムラインを同期させる）
  function synchronizeScrolling(scrollPosition) {
    // 日付ヘッダーのスクロール位置を同期
    const dateHeaders = document.getElementById('date-headers');
    if (dateHeaders) {
      dateHeaders.scrollLeft = scrollPosition;
    }
    
    // すべてのタイムラインのスクロール位置を同期
    const timelines = document.querySelectorAll('.gantt-timeline');
    timelines.forEach(timeline => {
      timeline.scrollLeft = scrollPosition;
    });
  }

  // 5. 日付スライダーの値も同期
  function updateDateSlider(scrollPosition) {
    const slider = document.getElementById('date-slider');
    const dateHeaders = document.getElementById('date-headers');
    
    if (slider && dateHeaders) {
      const scrollWidth = dateHeaders.scrollWidth - dateHeaders.clientWidth;
      if (scrollWidth > 0) {
        slider.value = (scrollPosition / scrollWidth) * 100;
      }
    }
  }

  // 4. 前の期間へ移動関数の修正
function moveToPreviousPeriod() {
  const newDate = new Date(startDate);
  newDate.setDate(newDate.getDate() - 13); // 13日前に移動
  startDate = newDate;
  updateGanttChart();
  
  // スライダーを左に設定
  const slider = document.getElementById('date-slider');
  if (slider) {
    slider.value = 0;
  }
}

  // 5. 次の期間へ移動関数の修正
function moveToNextPeriod() {
  const newDate = new Date(startDate);
  newDate.setDate(newDate.getDate() + 13); // 13日後に移動
  startDate = newDate;
  updateGanttChart();
  
  // スライダーを左に設定
  const slider = document.getElementById('date-slider');
  if (slider) {
    slider.value = 0;
  }
}



  // すべてのデータを取得する関数
  function fetchAllData() {
    console.log('データ取得開始');
    
    // 一定時間後に強制的にロード完了とする（フォールバック）
    const fallbackTimer = setTimeout(function() {
      console.log('データ取得タイムアウト - フォールバック実行');
      hideLoading();
      
      // メッセージ表示してリロードを促す
      if (!initialDataLoaded) {
        const container = document.querySelector('.container');
        if (container) {
          const message = document.createElement('div');
          message.innerHTML = `
            <div class="card-panel red lighten-4" style="margin-top: 20px;">
              <span class="red-text text-darken-4">
                データの読み込みに時間がかかっています。
                <button class="btn-small waves-effect waves-light" onclick="window.location.reload()">
                  <i class="material-icons left">refresh</i>再読み込み
                </button>
              </span>
            </div>
          `;
          container.prepend(message);
        }
      }
    }, 30000);
    
    // 機材リストを取得
    getEquipmentList();
    
    // 取得完了したらタイマーをクリア
    initialDataLoaded = true;
    clearTimeout(fallbackTimer);
  }
  
  // setupMobileEvents関数を完全に書き直し
  function setupMobileEvents() {
    try {
      console.log('モバイル向けイベント設定開始');
      
      // カレンダースワイプのセットアップ
      setupCalendarSwipe();
      
      // モバイル用の機材選択セレクトボックスイベント
      const mobileEquipmentSelect = document.getElementById('mobile-equipment-select');
      if (mobileEquipmentSelect) {
        const clone = mobileEquipmentSelect.cloneNode(true);
        mobileEquipmentSelect.parentNode.replaceChild(clone, mobileEquipmentSelect);
        
        clone.addEventListener('change', function(e) {
          console.log('Mobile equipment select changed:', e.target.value);
          selectedEquipmentWithLocation = e.target.value;
          const parts = selectedEquipmentWithLocation.split('|');
          selectedEquipment = parts[0]; // 機器管理番号部分
          selectedLocation = parts[1] || ''; // 定置場所部分
          updateGanttChart();
          
          // スクロール処理を確実に実行
          setTimeout(() => {
            scrollToSelectedEquipment();
          }, 500);
        });
      }
      
      // モバイルの「本日」ボタン
      document.getElementById('mobile-view-today')?.addEventListener('click', function() {
        startDate = new Date();
        startDate.setHours(0, 0, 0, 0);
        updateGanttChart();
      });
      
      // モバイルメニューボタン設定
      document.getElementById('mobile-menu-undo')?.addEventListener('click', function() {
        const undoButton = document.getElementById('undo-button');
        if (undoButton && !undoButton.disabled) {
          undoButton.click();
        }
      });
      
      document.getElementById('mobile-manage-projects')?.addEventListener('click', function() {
        openProjectsModal();
      });
      
      document.getElementById('mobile-manage-equipment')?.addEventListener('click', function() {
        // 機器マスター管理モーダルを開く関数を呼び出し
        const manageEquipmentBtn = document.getElementById('manage-equipment-btn');
        if (manageEquipmentBtn) {
          manageEquipmentBtn.click();
        }
      });
      
      // PCに戻すボタン
      document.getElementById('return-to-desktop')?.addEventListener('click', function() {
        document.body.classList.remove('mobile-view');
        updateMobileSettings();
        // スクロール位置をリセット
        savedScrollPosition = { top: 0, left: 0 };
        updateGanttChart();
      });
      
      // 文字サイズスライダー
      const fontSizeSlider = document.getElementById('font-size-slider');
      if (fontSizeSlider) {
        fontSizeSlider.addEventListener('input', function(e) {
          document.documentElement.style.setProperty('--base-font-size', e.target.value + 'px');
        });
      }
      
      console.log('モバイル向けイベント設定完了');
    } catch (error) {
      console.error('モバイル向けイベント設定エラー:', error);
    }
  }

  // モバイル表示でのスクロール同期
  function setupMobileScroll() {
    try {
      if (!document.body.classList.contains('mobile-view')) return;
      
      const dateHeaders = document.querySelector('#date-headers');
      const timelines = document.querySelectorAll('.gantt-timeline');
      
      if (!dateHeaders || !timelines.length) return;
      
      // 日付ヘッダーのスクロールイベント
      const scrollListener = function() {
        const scrollLeft = this.scrollLeft;
        
        // すべてのタイムラインを同期
        timelines.forEach(timeline => {
          if (timeline.scrollLeft !== scrollLeft) {
            timeline.scrollLeft = scrollLeft;
          }
        });
      };
      
      // 既存のイベントリスナーを削除
      dateHeaders.removeEventListener('scroll', scrollListener);
      
      // 新しいイベントリスナーを追加
      dateHeaders.addEventListener('scroll', scrollListener);
      
      // 初期スクロール位置を設定
      if (savedScrollPosition && savedScrollPosition.left > 0) {
        dateHeaders.scrollLeft = savedScrollPosition.left;
        timelines.forEach(timeline => {
          timeline.scrollLeft = savedScrollPosition.left;
        });
      }
    } catch (error) {
      console.error('モバイルスクロール設定エラー:', error);
    }
  }

  // 7. 日付ヘッダースクロールイベントハンドラ
  function onDateHeadersScroll(e) {
    // スワイプ中は同期しない（パフォーマンスのため）
    if (isSwiping) return;
    
    const scrollPosition = e.target.scrollLeft;
    
    // 各タイムラインを同期（日付ヘッダー自身は除く）
    const timelines = document.querySelectorAll('.gantt-timeline');
    timelines.forEach(timeline => {
      if (timeline.scrollLeft !== scrollPosition) {
        timeline.scrollLeft = scrollPosition;
      }
    });
    
    // スライダーも同期
    updateDateSlider(scrollPosition);
  }
  // 8. タイムラインスクロールイベントハンドラ
  function onTimelineScroll(e) {
    // スワイプ中は同期しない（パフォーマンスのため）
    if (isSwiping) return;
    
    const scrollPosition = e.target.scrollLeft;
    
    // 日付ヘッダーを同期
    const dateHeaders = document.getElementById('date-headers');
    if (dateHeaders && dateHeaders.scrollLeft !== scrollPosition) {
      dateHeaders.scrollLeft = scrollPosition;
    }
    
    // 他のタイムラインも同期（自分自身は除く）
    const timelines = document.querySelectorAll('.gantt-timeline');
    timelines.forEach(timeline => {
      if (timeline !== e.target && timeline.scrollLeft !== scrollPosition) {
        timeline.scrollLeft = scrollPosition;
      }
    });
    
    // スライダーも同期
    updateDateSlider(scrollPosition);
  }

  // 9. スライダー入力ハンドラ
  function onSliderInput(e) {
    const slider = e.target;
    const dateHeaders = document.getElementById('date-headers');
    
    if (dateHeaders) {
      const scrollWidth = dateHeaders.scrollWidth - dateHeaders.clientWidth;
      const newScrollPosition = (slider.value / 100) * scrollWidth;
      
      // 日付ヘッダーを同期
      dateHeaders.scrollLeft = newScrollPosition;
      
      // 各タイムラインも同期
      const timelines = document.querySelectorAll('.gantt-timeline');
      timelines.forEach(timeline => {
        timeline.scrollLeft = newScrollPosition;
      });
    }
  }

  // PC版のボタン修正
	function setupManagementButtons() {
	  // 現場マスター管理ボタン
	  const projectsBtn = document.getElementById('manage-projects-btn');
	  if (projectsBtn) {
	    // イベントリスナーをクリア
	    const projectsClone = projectsBtn.cloneNode(true);
	    projectsBtn.parentNode.replaceChild(projectsClone, projectsBtn);
	    
	    // 新しいイベントリスナーを追加
	    projectsClone.addEventListener('click', function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      console.log('Projects button clicked');
	      
	      // 現場マスター管理モーダルを表示
	      openProjectsModal();
	    });
	  }
	  
	  // 機器マスター管理ボタン
	  const equipmentBtn = document.getElementById('manage-equipment-btn');
	  if (equipmentBtn) {
	    // イベントリスナーをクリア
	    const equipmentClone = equipmentBtn.cloneNode(true);
	    equipmentBtn.parentNode.replaceChild(equipmentClone, equipmentBtn);
	    
	    // 新しいイベントリスナーを追加
	    equipmentClone.addEventListener('click', function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      console.log('Equipment button clicked');
	      
	      // 機器マスター管理モーダルを表示
	      openEquipmentModal();
	    });
	  }
	}

  // PC版フォントサイズスライダー追加
function setupPCFontSizeSlider() {
  try {
    // 既存のフォントサイズスライダー処理があれば取得
    let fontSizeSlider = document.getElementById('font-size-slider');
    if (fontSizeSlider) {
      // 初期値を16pxに設定（モバイルのデフォルト）
      fontSizeSlider.value = localStorage.getItem('fontSizeValue') || 16;
      
      // 既存のイベントを削除
      const newSlider = fontSizeSlider.cloneNode(true);
      fontSizeSlider.parentNode.replaceChild(newSlider, fontSizeSlider);
      fontSizeSlider = newSlider;
      
      // イベントリスナー設定
      fontSizeSlider.addEventListener('input', function() {
        const value = parseInt(this.value);
        document.documentElement.style.setProperty('--base-font-size', value + 'px');
        localStorage.setItem('fontSizeValue', value);
        
        // フォントサイズクラス要素のサイズを更新
        updateFontSizeByClass(value);
      });
      
      // 初期値を設定
      document.documentElement.style.setProperty('--base-font-size', fontSizeSlider.value + 'px');
      updateFontSizeByClass(parseInt(fontSizeSlider.value));
    }
    
    console.log('PC版フォントサイズスライダー設定完了');
  } catch (error) {
    console.error('PC版フォントサイズスライダー設定エラー:', error);
  }
}
// クラスベースのフォントサイズ更新
function updateFontSizeByClass(baseSize) {
  try {
    // モーダルのタイトル (h4) - 18px固定
    const modalTitles = document.querySelectorAll('.modal h4');
    modalTitles.forEach(element => {
      element.style.fontSize = '18px';
    });
    
    // モーダル内のサブタイトル (h5) - 16px固定
    const modalSubtitles = document.querySelectorAll('.modal h5');
    modalSubtitles.forEach(element => {
      element.style.fontSize = '16px';
    });
    
    // モバイルメニュータイトル - 18px固定
    const menuTitles = document.querySelectorAll('.mobile-menu-title');
    menuTitles.forEach(element => {
      element.style.fontSize = '18px';
    });
    
    // モバイル向け表示がオンの場合に特別なサイズ設定
    if (document.body.classList.contains('mobile-view')) {
      // モーダル内のフォーム要素とテキスト
      const modalTexts = document.querySelectorAll('.modal input, .modal select, .modal label, .modal .helper-text, .modal span, .modal .btn, .modal .btn-flat');
      modalTexts.forEach(element => {
        element.style.fontSize = '16px';
      });
      
      // ガントチャート内のテキスト
      const chartTexts = document.querySelectorAll('.gantt-item, .equipment-name, .equipment-location, .equipment-stock, .equipment-detail, .gantt-date, .date-display-area, .rental-bar');
      chartTexts.forEach(element => {
        element.style.fontSize = '16px';
      });
      
      // ボタンとコントロール要素
      const controlElements = document.querySelectorAll('.btn, .btn-flat, .settings-panel span, .user-info, .date-picker-container, .date-slider-label');
      controlElements.forEach(element => {
        element.style.fontSize = '16px';
      });
      
      // テーブル内のテキスト
      const tableTexts = document.querySelectorAll('table.striped th, table.striped td');
      tableTexts.forEach(element => {
        element.style.fontSize = '16px';
      });
    } else {
      // PC表示の場合は通常のスケーリングを使用
      const fontAdjustables = document.querySelectorAll('.font-adjusted');
      fontAdjustables.forEach(element => {
        if (element.dataset.fontSizeMultiplier) {
          const multiplier = parseFloat(element.dataset.fontSizeMultiplier);
          element.style.fontSize = (baseSize * multiplier) + 'px';
        } else {
          element.style.fontSize = baseSize + 'px';
        }
      });
    }
  } catch (error) {
    console.error('フォントサイズクラス更新エラー:', error);
  }
}
  // PC版フォントサイズ更新
  function updatePCFontSize(fontSize) {
	  document.documentElement.style.setProperty('--pc-font-size', fontSize + 'px');
	  
	  // PCモードの場合のみフォントサイズ適用
	  if (!document.body.classList.contains('mobile-view')) {
	    document.body.style.fontSize = fontSize + 'px';
	    
	    // 重要なクラスに明示的にフォントサイズを設定
	    document.querySelectorAll('.gantt-item, .gantt-date, .equipment-name, .equipment-detail').forEach(el => {
	      el.style.fontSize = fontSize + 'px';
	    });
	    
	    // モーダル内の要素にもフォントサイズを設定
	    document.querySelectorAll('.modal .modal-content, .modal-footer, .modal label, .modal input, .modal select').forEach(el => {
	      el.style.fontSize = fontSize + 'px';
	    });
	    
	    // 確認チェックボックスのテキストサイズ修正
	    document.querySelectorAll('.settings-panel span').forEach(el => {
	      el.style.fontSize = fontSize + 'px';
	    });
	  }
	}

  // カレンダーナビゲーションボタンの修正
	function setupCalendarNavigation() {
	  const navigationDiv = document.createElement('div');
	  navigationDiv.className = 'calendar-navigation';
	  navigationDiv.innerHTML = `
	    <button class="btn waves-effect waves-light" id="prev-period-btn">
	      <i class="material-icons">arrow_back</i> 前
	    </button>
	    <button class="btn waves-effect waves-light" id="today-btn">
	      <i class="material-icons">today</i> 本日
	    </button>
	    <button class="btn waves-effect waves-light" id="next-period-btn">
	      <i class="material-icons">arrow_forward</i> 次
	    </button>
	  `;
	  
	  // 表示エリアの上部に追加
	  const ganttContainer = document.querySelector('.gantt-container');
	  if (ganttContainer) {
	    ganttContainer.parentNode.insertBefore(navigationDiv, ganttContainer);
	    
	    // イベントリスナーを追加
	    document.getElementById('prev-period-btn')?.addEventListener('click', function() {
	      // 13日前に移動
	      const newDate = new Date(startDate);
	      newDate.setDate(newDate.getDate() - 13);
	      startDate = newDate;
	      updateGanttChart();
	    });
	    
	    document.getElementById('today-btn')?.addEventListener('click', function() {
	      startDate = new Date();
	      startDate.setHours(0, 0, 0, 0);
	      updateGanttChart();
	    });
	    
	    document.getElementById('next-period-btn')?.addEventListener('click', function() {
	      // 13日後に移動
	      const newDate = new Date(startDate);
	      newDate.setDate(newDate.getDate() + 13);
	      startDate = newDate;
	      updateGanttChart();
	    });
	  }
	}
	
	// すべてのモーダルを閉じる関数
	function closeAllModals() {
	  const modals = document.querySelectorAll('.modal');
	  modals.forEach(modal => {
	    try {
	      const instance = M.Modal.getInstance(modal);
	      if (instance) instance.close();
	    } catch (error) {
	      console.error('モーダルクローズエラー:', error);
	    }
	  });
	}
	
	// 日付選択用のカレンダーを設定する関数
	function setupDatePickers() {
	  // すべての日付入力フィールドにデートピッカーを適用
	  const dateInputs = document.querySelectorAll('input[type="date"], input.datepicker');
	  dateInputs.forEach(input => {
	    // HTML5のtype="date"を解除して標準のテキスト入力にする
	    input.type = 'text';
	    input.classList.add('datepicker');
	    
	    // Materializeのデートピッカーを初期化
	    const options = {
	      format: 'yyyy-mm-dd',
	      autoClose: true,
	      setDefaultDate: input.value ? true : false,
	      defaultDate: input.value ? new Date(input.value) : null,
	      onSelect: function(date) {
	        // 選択した日付を設定
	        input.value = formatDate(date);
	        
	        // changeイベントを発火させる
	        const event = new Event('change', { bubbles: true });
	        input.dispatchEvent(event);
	      }
	    };
	    
	    M.Datepicker.init(input, options);
	  });
	  
	  // カスタム日付ピッカー
	  const customDatePicker = document.getElementById('custom-date-picker');
	  if (customDatePicker) {
	    customDatePicker.type = 'text';
	    customDatePicker.classList.add('datepicker');
	    
	    const datepickerInstance = M.Datepicker.init(customDatePicker, {
	      format: 'yyyy-mm-dd',
	      autoClose: true,
	      onSelect: function(date) {
	        startDate = date;
	        updateGanttChart();
	      }
	    });
	    
	    // カレンダーアイコンクリックでカレンダーを表示
	    const calendarTrigger = document.getElementById('calendar-trigger');
	    if (calendarTrigger) {
	      calendarTrigger.addEventListener('click', function() {
	        if (datepickerInstance) {
	          datepickerInstance.open();
	        }
	      });
	    }
	  }
	}
	
	// 数量変更ボタンのイベントリスナー設定
	function setupQuantityControls() {
    try {
      // マイナスボタン
      const minusBtn = document.querySelector('.quantity-btn.minus');
      if (minusBtn) {
        // 既存のイベントリスナーをクリア
        const newMinusBtn = minusBtn.cloneNode(true);
        minusBtn.parentNode.replaceChild(newMinusBtn, minusBtn);
        
        // 新しいイベントリスナーを追加
        newMinusBtn.addEventListener('click', function() {
          const input = document.getElementById('rental-quantity');
          if (!input) return;
          
          let value = parseInt(input.value) || 1;
          if (value > 1) {
            value = value - 1; // 明示的に減算
            input.value = value;
          }
        });
      }
      
      // プラスボタン
      const plusBtn = document.querySelector('.quantity-btn.plus');
      if (plusBtn) {
        // 既存のイベントリスナーをクリア
        const newPlusBtn = plusBtn.cloneNode(true);
        plusBtn.parentNode.replaceChild(newPlusBtn, plusBtn);
        
        // 新しいイベントリスナーを追加
        newPlusBtn.addEventListener('click', function() {
          const input = document.getElementById('rental-quantity');
          if (!input) return;
          
          let value = parseInt(input.value) || 1;
          value = value + 1; // 明示的に加算
          input.value = value;
        });
      }
      
      console.log('数量コントロール設定完了');
    } catch (error) {
      console.error('数量コントロール設定エラー:', error);
    }
  }
	// 日付スライダーのセットアップ
function setupDateSlider() {
  try {
    const ganttContainer = document.querySelector('.gantt-container');
    if (!ganttContainer) return;
    
    // 既存のスライダーがあれば削除
    const oldSlider = document.querySelector('.date-slider-container');
    if (oldSlider) {
      oldSlider.remove();
    }
    
    // スライダーコンテナの作成
    const sliderContainer = document.createElement('div');
    sliderContainer.className = 'date-slider-container';
    
    // 前月ラベル
    const prevLabel = document.createElement('span');
    prevLabel.className = 'date-slider-label';
    prevLabel.textContent = '前月';
    prevLabel.addEventListener('click', function() {
      moveCalendarByMonths(-1);
    });
    
    // スライダー
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.id = 'date-slider';
    slider.min = '0';
    slider.max = '100';
    slider.value = '0';
    
    // 次月ラベル
    const nextLabel = document.createElement('span');
    nextLabel.className = 'date-slider-label';
    nextLabel.textContent = '次月';
    nextLabel.addEventListener('click', function() {
      moveCalendarByMonths(1);
    });
    
    // 本日ボタン
    const todayButton = document.createElement('button');
    todayButton.className = 'date-slider-today';
    todayButton.innerHTML = '<i class="material-icons">today</i>本日';
    todayButton.addEventListener('click', function() {
      startDate = new Date();
      startDate.setHours(0, 0, 0, 0);
      updateGanttChart();
    });
    
    // 要素を追加
    sliderContainer.appendChild(prevLabel);
    sliderContainer.appendChild(slider);
    sliderContainer.appendChild(nextLabel);
    sliderContainer.appendChild(todayButton);
    
    // ガントチャートの前に挿入
    ganttContainer.insertBefore(sliderContainer, ganttContainer.firstChild);
    
    // 日付ヘッダーへの参照を取得
    const dateHeaders = document.getElementById('date-headers');
    
    if (dateHeaders) {
      // スライダー変更イベント
      slider.addEventListener('input', function() {
        if (!dateHeaders) return;
        
        // スライダー値に基づいてスクロール位置を計算
        const value = parseInt(this.value);
        const maxScrollLeft = dateHeaders.scrollWidth - dateHeaders.clientWidth;
        const newScrollLeft = (value / 100) * maxScrollLeft;
        
        // スクロール位置を設定
        dateHeaders.scrollLeft = newScrollLeft;
        
        // タイムラインも同期
        const timelines = document.querySelectorAll('.gantt-timeline');
        timelines.forEach(timeline => {
          timeline.scrollLeft = newScrollLeft;
        });
        
        // スクロール位置を保存
        savedScrollPosition.left = newScrollLeft;
      });
      
      // 日付ヘッダーのスクロールイベント - スライダーを同期
      dateHeaders.addEventListener('scroll', function() {
        const maxScrollLeft = this.scrollWidth - this.clientWidth;
        if (maxScrollLeft <= 0) return;
        
        // スライダー値を計算
        const sliderValue = (this.scrollLeft / maxScrollLeft) * 100;
        
        // スライダー値を設定
        slider.value = sliderValue;
      });
      
      // 初期スクロール位置の設定
      setTimeout(() => {
        if (savedScrollPosition && savedScrollPosition.left > 0) {
          dateHeaders.scrollLeft = savedScrollPosition.left;
          
          // スライダーも同期
          const maxScrollLeft = dateHeaders.scrollWidth - dateHeaders.clientWidth;
          if (maxScrollLeft > 0) {
            slider.value = (savedScrollPosition.left / maxScrollLeft) * 100;
          }
          
          // タイムラインも同期
          const timelines = document.querySelectorAll('.gantt-timeline');
          timelines.forEach(timeline => {
            timeline.scrollLeft = savedScrollPosition.left;
          });
        }
      }, 100);
    }
  } catch (error) {
    console.error('日付スライダー設定エラー:', error);
  }
}


  // 10. 貸出バーの位置調整とZ-index処理
  function adjustRentalBarPositioning() {
    // ガントチャート内のすべての貸出バーを取得
    const rentalBars = document.querySelectorAll('.rental-bar');
    if (!rentalBars.length) return;
    
    // 機材名セルの幅を取得
    const equipmentNameCell = document.querySelector('.gantt-item');
    const equipmentNameCellWidth = equipmentNameCell ? equipmentNameCell.offsetWidth : 250;
    
    // モバイル表示かどうかをチェック
    const isMobileView = document.body.classList.contains('mobile-view');
    
    // 各貸出バーを調整
    rentalBars.forEach(bar => {
      // モバイル表示の場合、貸出バーのzIndexを調整
      if (isMobileView) {
        bar.style.zIndex = '15'; // 機材名セルより低い値
        
        // オリジナルの位置を保存
        if (!bar.dataset.originalLeft) {
          bar.dataset.originalLeft = bar.style.left;
        }
      }
    });
  }

  // 13. ガントチャート更新後に貸出バーの位置調整を行う
  function updateGanttChartWithBarAdjustment() {
    // 標準のガントチャート更新処理を実行
    updateGanttChart();
    
    // 短い遅延を設けて、DOM構築完了後に貸出バー調整を実行
    setTimeout(() => {
      adjustRentalBarPositioning();
    }, 200);
  }



	// 2. タイムラインのスクロールを同期する関数（新規）
  function syncTimelineScroll(scrollPos) {
    const timelines = document.querySelectorAll('.gantt-timeline');
    timelines.forEach(timeline => {
      timeline.scrollLeft = scrollPos;
    });
  }
  // 11. モバイル向けの機材名カラム修正用のスタイル追加
  function addMobileColumnFixStyles() {
    // 既存のスタイルがあれば削除
    const existingStyle = document.getElementById('mobile-column-fix-styles');
    if (existingStyle) {
      existingStyle.remove();
    }
    
    // 新しいスタイル要素を作成
    const styleElement = document.createElement('style');
    styleElement.id = 'mobile-column-fix-styles';
    styleElement.textContent = `
      /* 機材名カラムを完全に固定 */
      @media screen and (max-width: 768px) {
        /* 機材名カラムを完全に固定 */
        .gantt-item {
          position: -webkit-sticky !important;
          position: sticky !important;
          left: 0 !important;
          z-index: 20 !important;
          background-color: #fff !important;
          border-right: 2px solid #26a69a !important;
          box-shadow: 3px 0 5px rgba(0, 0, 0, 0.2) !important;
          will-change: transform !important;
          transform: translateZ(0) !important;
          backface-visibility: hidden !important;
          perspective: 1000px !important;
        }
        
        /* ヘッダーの機材名カラムも同様に */
        .gantt-header .gantt-item {
          position: -webkit-sticky !important;
          position: sticky !important;
          left: 0 !important;
          z-index: 30 !important;
          background-color: #f5f5f5 !important;
          border-right: 2px solid #26a69a !important;
          box-shadow: 3px 0 5px rgba(0, 0, 0, 0.2) !important;
          will-change: transform !important;
          transform: translateZ(0) !important;
          backface-visibility: hidden !important;
          perspective: 1000px !important;
        }
        
        /* スワイプ中の機材名カラムは特に固定 */
        body.swiping .gantt-item {
          transform: none !important;
          transition: none !important;
        }
        
        /* 日付部分のコンテナをより安定化 */
        .gantt-dates,
        .gantt-timeline {
          position: relative !important;
          will-change: scroll-position !important;
          transform: translateZ(0) !important;
          backface-visibility: hidden !important;
          overflow-x: auto !important;
          overflow-y: hidden !important;
          -webkit-overflow-scrolling: touch !important;
          scroll-behavior: smooth !important;
          margin-left: 250px !important; /* 機材名の幅分のマージン */
          width: calc(100% - 250px) !important; /* 機材名の幅を除いた幅 */
        }

        /* スクロール連動を強化 */
        .gantt-dates::-webkit-scrollbar,
        .gantt-timeline::-webkit-scrollbar {
          height: 0;
          display: none;
        }
        
        /* 選択された行のスタイル適用 */
        .selected-equipment .gantt-item {
          background-color: #e3f2fd !important;
        }
        
        /* 偶数行の背景色 */
        .gantt-row:nth-child(even) .gantt-item {
          background-color: #f8f8f8 !important;
        }
        
        /* 奇数行の背景色 */
        .gantt-row:nth-child(odd) .gantt-item {
          background-color: #fff !important;
        }
      }
    `;
    
    // スタイルをヘッドに追加
    document.head.appendChild(styleElement);
  }
// 3. 本日へ移動する関数（新規）
function goToToday() {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  startDate = today;
  updateGanttChart();
  
  // スライダーを左に設定
  const slider = document.getElementById('date-slider');
  if (slider) {
    slider.value = 0;
  }
}
// スクロール同期を強化する関数
function setupScrollSynchronization() {
  // 日付ヘッダーを取得
  const dateHeaders = document.getElementById('date-headers');
  if (!dateHeaders) return;
  
  // タイムライン要素をすべて取得
  const timelines = document.querySelectorAll('.gantt-timeline');
  if (!timelines.length) return;
  
  // 日付ヘッダーのスクロールイベント処理
  dateHeaders.addEventListener('scroll', function() {
    // すべてのタイムラインのスクロール位置を同期
    const scrollLeft = dateHeaders.scrollLeft;
    timelines.forEach(timeline => {
      if (timeline.scrollLeft !== scrollLeft) {
        timeline.scrollLeft = scrollLeft;
      }
    });
    
    // 貸出バーの位置を調整
    adjustRentalBarsVisibility(scrollLeft);
  });
  
  // 各タイムラインのスクロールイベント処理も設定
  timelines.forEach(timeline => {
    timeline.addEventListener('scroll', function() {
      // このタイムラインのスクロール位置を取得
      const scrollLeft = timeline.scrollLeft;
      
      // 日付ヘッダーと他のすべてのタイムラインを同期
      if (dateHeaders.scrollLeft !== scrollLeft) {
        dateHeaders.scrollLeft = scrollLeft;
      }
      
      // 他のタイムラインも同期
      timelines.forEach(otherTimeline => {
        if (otherTimeline !== timeline && otherTimeline.scrollLeft !== scrollLeft) {
          otherTimeline.scrollLeft = scrollLeft;
        }
      });
      
      // 貸出バーの位置を調整
      adjustRentalBarsVisibility(scrollLeft);
    });
  });
  
  console.log('スクロール同期設定完了');
}

// 貸出バーの表示問題を解決する完全修正
function createRentalBarForMobile(timeline, rental, days, cellWidth, layer, location) {
  try {
    // 日付範囲の取得
    const startDay = parseDate(rental['借用開始日']);
    const endDay = parseDate(rental['借用終了日']);
    
    if (!startDay || !endDay) {
      console.error('貸出の日付が無効:', rental);
      return null;
    }
    
    // 日付を正規化
    startDay.setHours(0, 0, 0, 0);
    endDay.setHours(0, 0, 0, 0);
    
    // 表示範囲
    const rangeStart = new Date(days[0]);
    const rangeEnd = new Date(days[days.length - 1]);
    rangeStart.setHours(0, 0, 0, 0);
    rangeEnd.setHours(23, 59, 59, 999);
    
    // 範囲外なら表示しない
    if (endDay < rangeStart || startDay > rangeEnd) {
      return null;
    }
    
    // 表示範囲内の日付に調整
    let visibleStartDay = new Date(Math.max(startDay.getTime(), rangeStart.getTime()));
    let visibleEndDay = new Date(Math.min(endDay.getTime(), rangeEnd.getTime()));
    
    // 日付のインデックスを計算
    let startIdx = -1;
    let endIdx = -1;
    
    for (let i = 0; i < days.length; i++) {
      const currentDay = new Date(days[i]);
      currentDay.setHours(0, 0, 0, 0);
      
      // 開始日インデックスを検索
      if (startIdx === -1) {
        if (visibleStartDay.getTime() <= currentDay.getTime()) {
          startIdx = i;
        }
        if (visibleStartDay.getTime() === currentDay.getTime()) {
          startIdx = i;
          break; // 完全一致したら検索終了
        }
      }
    }
    
    for (let i = 0; i < days.length; i++) {
      const currentDay = new Date(days[i]);
      currentDay.setHours(0, 0, 0, 0);
      
      // 終了日インデックスを検索
      if (visibleEndDay.getTime() >= currentDay.getTime()) {
        endIdx = i;
      }
      if (visibleEndDay.getTime() === currentDay.getTime()) {
        endIdx = i;
        break; // 完全一致したら検索終了
      }
    }
    
    // インデックスチェック
    if (startIdx === -1 || endIdx === -1 || startIdx > endIdx) {
      console.warn('インデックス計算エラー:', { startIdx, endIdx, rental });
      return null;
    }
    
    // バーの位置とサイズを計算
    const width = ((endIdx - startIdx) + 1) * cellWidth;
    const left = startIdx * cellWidth;
    const top = layer * 40 + 10; // 10pxの余白を追加
    
    // バー要素作成
    const bar = document.createElement('div');
    bar.className = 'rental-bar';
    bar.style.position = 'absolute';
    bar.style.left = left + 'px';
    bar.style.top = top + 'px';
    bar.style.width = width + 'px';
    bar.style.height = '40px';
    bar.style.borderRadius = '3px';
    bar.style.color = 'white';
    bar.style.padding = '5px 30px 5px 5px';
    bar.style.fontSize = '16px';
    bar.style.zIndex = '15';
    bar.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
    bar.style.overflow = 'hidden';
    bar.style.textOverflow = 'ellipsis';
    bar.style.whiteSpace = 'nowrap';
    bar.style.display = 'flex';
    bar.style.alignItems = 'center';

    // 重要: 元の位置情報を保存
    bar.dataset.originalLeft = left;
    bar.dataset.originalWidth = width;
    bar.dataset.startIdx = startIdx;
    bar.dataset.endIdx = endIdx;
    bar.dataset.startDate = formatDate(startDay);
    bar.dataset.endDate = formatDate(endDay);

    // バーデータとテキスト
    bar.dataset.rentalId = rental['登録日時'] ? rental['登録日時'].toString() : '';
    bar.dataset.layer = layer;
    bar.dataset.location = location;

    // 貸出情報を表示
    bar.textContent = `${rental['数量']}台-${rental['使用場所']}(${getUserDisplayName(rental['借用者'])})`;
    
    // 定置場所と使用場所に基づいて色を決定
    if (location && rental['使用場所'] && location === rental['使用場所']) {
      // 同じ場所の場合は緑色
      bar.style.backgroundColor = '#26a69a';
    } else {
      // 異なる場所の場合はオレンジ色
      bar.style.backgroundColor = '#ff9800';
    }

    // ドラッグ＆リサイズ機能を有効化
    enableBarDragAndResize(bar, rental);

    // タイムラインに追加
    timeline.appendChild(bar);
    
    return bar;
  } catch (error) {
    console.error('貸出バー作成エラー:', error);
    return null;
  }
}

  // 貸出バーの表示/位置調整関数
  // 貸出バーの表示調整関数を完全修正
  // 貸出バーの表示を最適化
  function adjustRentalBarsVisibility(scrollLeft) {
    try {
      // パフォーマンス最適化: アニメーションフレームを使用
      if (window.barAdjustmentAnimationFrame) {
        cancelAnimationFrame(window.barAdjustmentAnimationFrame);
      }
      
      window.barAdjustmentAnimationFrame = requestAnimationFrame(() => {
        // モバイル表示でない場合は処理しない
        if (!document.body.classList.contains('mobile-view')) return;
        
        // すべての貸出バーを取得
        const rentalBars = document.querySelectorAll('.rental-bar');
        if (!rentalBars.length) return;
        
        // 機材名セルの幅を取得
        const itemWidth = 250; // 固定値に変更
        
        // ガントチャートコンテナの幅を取得
        const ganttContainer = document.querySelector('.gantt-container');
        const containerWidth = ganttContainer ? ganttContainer.offsetWidth : window.innerWidth;
        const viewportWidth = containerWidth - itemWidth;
        
        // バーの表示を一括更新するために変更を集約
        const barsToUpdate = [];
        
        // 各貸出バーを処理
        rentalBars.forEach(bar => {
          // 元の位置情報を取得
          const originalLeft = parseInt(bar.dataset.originalLeft || 0);
          const originalWidth = parseInt(bar.dataset.originalWidth || bar.style.width);
          
          // スクロール位置から見た相対位置
          const relativeLeft = originalLeft - scrollLeft;
          
          // 視覚範囲内かどうか判定
          const barRight = relativeLeft + originalWidth;
          const isVisible = barRight > 0 && relativeLeft < viewportWidth + itemWidth;
          
          if (isVisible) {
            // 機材名セルとの位置関係を処理
            let adjustedLeft, adjustedWidth;
            
            if (relativeLeft < itemWidth) {
              // 機材名セルと重なる部分がある場合
              const visibleWidth = originalWidth - (itemWidth - relativeLeft);
              
              if (visibleWidth > 5) {
                // 表示部分が十分ある場合は位置調整
                adjustedLeft = itemWidth;
                adjustedWidth = visibleWidth;
                barsToUpdate.push({
                  bar,
                  display: 'flex',
                  left: adjustedLeft,
                  width: adjustedWidth
                });
              } else {
                // 表示部分が小さすぎる場合は非表示
                barsToUpdate.push({
                  bar,
                  display: 'none'
                });
              }
            } else {
              // 機材名セルと重ならない場合は通常表示
              barsToUpdate.push({
                bar,
                display: 'flex',
                left: relativeLeft,
                width: originalWidth
              });
            }
          } else {
            // 視覚範囲外は非表示
            barsToUpdate.push({
              bar,
              display: 'none'
            });
          }
        });
        
        // バッチ処理で一括更新（レイアウトスラッシングを防止）
        barsToUpdate.forEach(update => {
          const { bar, display, left, width } = update;
          
          // 現在の状態と異なる場合のみ更新
          if (bar.style.display !== display) {
            bar.style.display = display;
          }
          
          if (display === 'flex') {
            if (parseInt(bar.style.left) !== left) {
              bar.style.left = `${left}px`;
            }
            
            if (parseInt(bar.style.width) !== width) {
              bar.style.width = `${width}px`;
            }
          }
        });
      });
    } catch (err) {
      console.error('貸出バー表示調整エラー:', err);
    }
  }

  // モバイル向けのガントチャート描画完了後の処理
  function onMobileGanttChartRendered() {
    // スクロール同期を設定
    setupScrollSynchronization();
    
    // 貸出バーの元の位置情報を保存
    const rentalBars = document.querySelectorAll('.rental-bar');
    rentalBars.forEach(bar => {
      const left = parseInt(bar.style.left);
      if (!isNaN(left)) {
        bar.dataset.originalLeft = left;
      }
    });
    
    // 初期スクロール位置での貸出バー表示調整
    const dateHeaders = document.getElementById('date-headers');
    if (dateHeaders) {
      adjustRentalBarsVisibility(dateHeaders.scrollLeft);
    }
    
    console.log('モバイルガントチャート後処理完了');
  }
  // スワイプ操作時のスクロール位置とクラスを管理
  function setSwipingMode(isOn) {
    if (isOn) {
      document.body.classList.add('swiping');
      // スワイプ中はスクロール同期を一時停止
      window.isScrollPropagating = true;
    } else {
      document.body.classList.remove('swiping');
      // スワイプ終了時にフラグを解除
      setTimeout(() => {
        window.isScrollPropagating = false;
      }, 100);
    }
  }

  // updateGanttChart関数修正 - 描画完了後の処理追加
  function updateGanttChart() {
    try {
      showLoading();
      console.log('ガントチャート更新開始');
      
      // スワイプモードを解除
      setSwipingMode(false);
      
      // 選択中の機材と定置場所の情報を保存
      saveCurrentSelection();
      
      // スワイプ操作からの更新かどうかを判定
      const isSwipeUpdate = isSwiping || (Date.now() - swipeEndTime < 500);
      
      // スワイプ更新の場合、スクロールをスキップするフラグを立てる
      if (isSwipeUpdate) {
        skipScrollToSelectedEquipment = true;
      }
      
      // 表示する日数を拡張
      let endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 30); // 30日分表示
      
      // 日付配列作成
      const days = [];
      const tempDate = new Date(startDate);
      while (tempDate < endDate) {
        days.push(new Date(tempDate));
        tempDate.setDate(tempDate.getDate() + 1);
      }
      
      // モバイル対応のためのレイアウト変更
      if (document.body.classList.contains('mobile-view')) {
        // モバイルレイアウトの作成
        createMobileLayout(days);
        
        // モバイル描画後の設定
        setTimeout(() => {
          // 完全同期スクロールセットアップ
          setupCompleteScrollSync();
          
          // 貸出バーの表示調整
          const dateHeaders = document.getElementById('date-headers');
          if (dateHeaders) {
            adjustRentalBarsVisibility(dateHeaders.scrollLeft);
          }
        }, 100);
      } else {
        // PC向けレイアウトの作成
        createDesktopLayout(days);
      }
      
      // ガントチャートの高さを調整
      adjustGanttHeight();
      
      // 日付スライダーを追加
      setupDateSlider();
      
      hideLoading();
      
      // スワイプ更新ではない場合のみ、選択中の機材までスクロール
      if (!skipScrollToSelectedEquipment && !isSwipeUpdate) {
        scrollToSelectedEquipment();
      } else {
        // 次回の更新では通常スクロールに戻す
        setTimeout(() => {
          skipScrollToSelectedEquipment = false;
        }, 500);
      }
    } catch (error) {
      console.error('ガントチャート更新エラー:', error);
      hideLoading();
      alert('ガントチャートの更新中にエラーが発生しました: ' + error);
    }
  }

  // 完全同期スクロールシステム
  function setupCompleteScrollSync() {
    try {
      // 日付ヘッダーとタイムライン要素を取得
      const dateHeaders = document.getElementById('date-headers');
      const timelines = document.querySelectorAll('.gantt-timeline');
      
      if (!dateHeaders || !timelines.length) {
        console.error('スクロール同期に必要な要素が見つかりません');
        return;
      }
      
      // アニメーションフレームを使った同期関数
      function syncScroll(scrollLeft, sourceElement) {
        // 既存のアニメーションフレームをキャンセル
        if (window.syncScrollFrame) {
          cancelAnimationFrame(window.syncScrollFrame);
        }
        
        // 新しいアニメーションフレームで処理
        window.syncScrollFrame = requestAnimationFrame(() => {
          // 日付ヘッダーのスクロール位置を更新
          if (sourceElement !== dateHeaders && dateHeaders.scrollLeft !== scrollLeft) {
            dateHeaders.scrollLeft = scrollLeft;
          }
          
          // すべてのタイムラインのスクロール位置を更新
          timelines.forEach(timeline => {
            if (sourceElement !== timeline && timeline.scrollLeft !== scrollLeft) {
              timeline.scrollLeft = scrollLeft;
            }
          });
          
          // 貸出バーの表示を調整
          adjustRentalBarsVisibility(scrollLeft);
        });
      }
      
      // 日付ヘッダーのスクロールイベント
      dateHeaders.addEventListener('scroll', function() {
        // スワイプ中は処理しない
        if (isSwiping) return;
        
        syncScroll(dateHeaders.scrollLeft, dateHeaders);
      }, { passive: true });
      
      // 各タイムラインのスクロールイベント
      timelines.forEach(timeline => {
        timeline.addEventListener('scroll', function() {
          // スワイプ中は処理しない
          if (isSwiping) return;
          
          syncScroll(timeline.scrollLeft, timeline);
        }, { passive: true });
      });
      
      console.log('完全同期スクロール設定完了');
    } catch (err) {
      console.error('完全同期スクロール設定エラー:', err);
    }
  }

  // updateGanttChart関数の修正 - スクロール位置維持とスキップフラグ
  function updateGanttChart() {
    try {
      showLoading();
      console.log('ガントチャート更新開始');
      
      // 選択中の機材と定置場所の情報を保存
      saveCurrentSelection();
      
      // スクロール位置を一時保存
      const dateHeaders = document.getElementById('date-headers');
      let savedScrollPosition = 0;
      if (dateHeaders) {
        savedScrollPosition = dateHeaders.scrollLeft;
      }
      
      // スワイプ操作からの更新かどうかを判定
      const isSwipeUpdate = isSwiping || (Date.now() - swipeEndTime < 1000);
      if (isSwipeUpdate) {
        // スワイプによる更新の場合はスクロールをスキップ
        skipScrollToSelectedEquipment = true;
      }
      
      // 表示する日数を拡張（より多くの日付を表示）
      let endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 30); // 30日分表示に変更
      
      // 日付配列作成
      const days = [];
      const tempDate = new Date(startDate);
      while (tempDate < endDate) {
        days.push(new Date(tempDate));
        tempDate.setDate(tempDate.getDate() + 1);
      }
      
      // モバイル対応のためのレイアウト変更
      if (document.body.classList.contains('mobile-view')) {
        // モバイルレイアウトの作成
        createMobileLayout(days);
        
        // モバイル描画後のステップ
        setTimeout(() => {
          // 完全同期スクロールセットアップ
          setupCompleteScrollSync();
          
          // スワイプ更新の場合、前回のスクロール位置を復元
          if (isSwipeUpdate && dateHeaders) {
            const newDateHeaders = document.getElementById('date-headers');
            if (newDateHeaders) {
              // スワイプ操作で移動した場合は日付の先頭にスクロール
              newDateHeaders.scrollLeft = 0;
            }
          }
          
          // 貸出バーの表示調整
          const newDateHeaders = document.getElementById('date-headers');
          if (newDateHeaders) {
            adjustRentalBarsVisibility(newDateHeaders.scrollLeft);
          }
        }, 100);
      } else {
        // PC向けレイアウトの作成
        createDesktopLayout(days);
      }
      
      // ガントチャートの高さを調整
      adjustGanttHeight();
      
      // 日付スライダーを追加
      setupDateSlider();
      
      hideLoading();
      
      // スワイプ更新ではない場合のみ、選択中の機材までスクロール
      if (!skipScrollToSelectedEquipment && !isSwipeUpdate) {
        scrollToSelectedEquipment();
      } else {
        // 次回の更新では通常スクロールに戻す
        setTimeout(() => {
          skipScrollToSelectedEquipment = false;
        }, 1000);
      }
    } catch (error) {
      console.error('ガントチャート更新エラー:', error);
      hideLoading();
      alert('ガントチャートの更新中にエラーが発生しました: ' + error);
    }
  }

  // 貸出バーの表示調整関数を改善
  function adjustRentalBarsVisibility(scrollLeft) {
    try {
      // モバイル表示でない場合は処理しない
      if (!document.body.classList.contains('mobile-view')) return;
      
      // すべての貸出バーを取得
      const rentalBars = document.querySelectorAll('.rental-bar');
      if (!rentalBars.length) return;
      
      // 機材名セルの幅を取得
      const ganttItem = document.querySelector('.gantt-item');
      const itemWidth = ganttItem ? ganttItem.offsetWidth : 250;
      
      // セル幅を取得
      const cellWidth = userSettings.mobileCellWidth || 80;
      
      // ガントチャートコンテナの幅を取得
      const ganttContainer = document.querySelector('.gantt-container');
      const containerWidth = ganttContainer ? ganttContainer.offsetWidth : window.innerWidth;
      
      // 各貸出バーを処理
      rentalBars.forEach(bar => {
        // 元の位置情報を取得
        const originalLeft = parseInt(bar.dataset.originalLeft || 0);
        const barWidth = parseInt(bar.dataset.originalWidth || bar.style.width);
        
        // スクロール位置から見た相対位置を計算
        const relativeLeft = originalLeft - scrollLeft;
        
        // 視覚範囲内かどうか判定
        const isInView = (relativeLeft + barWidth > 0) && (relativeLeft < containerWidth);
        
        if (isInView) {
          // 表示対象
          bar.style.display = 'flex';
          
          // 機材名セルとの位置関係を処理
          if (relativeLeft < itemWidth) {
            // 機材名セルと重なる部分がある場合
            const visibleWidth = barWidth - (itemWidth - relativeLeft);
            
            if (visibleWidth > 10) {
              // 表示部分が十分ある場合は位置調整して表示
              bar.style.left = `${itemWidth}px`;
              bar.style.width = `${visibleWidth}px`;
            } else {
              // 表示部分が小さすぎる場合は非表示
              bar.style.display = 'none';
            }
          } else {
            // 機材名セルと重ならない場合は通常表示
            bar.style.left = `${relativeLeft}px`;
            bar.style.width = `${barWidth}px`;
          }
        } else {
          // 視覚範囲外は非表示
          bar.style.display = 'none';
        }
      });
    } catch (err) {
      console.error('貸出バー表示調整エラー:', err);
    }
  }
  /**
   * モバイル表示用JavaScript処理の修正
   * 
   * 1. createMobileLayout - モバイル版レイアウト作成関数の修正
   * 2. モバイル用スクロール処理の連携強化
   * 3. カレンダースワイプ処理の改善
   */

  
  // 2. 貸出バー作成関数（位置とスタイルを適切に設定）
function createRentalBarWithProperPosition(timeline, rental, startIdx, endIdx, layer, cellWidth) {
  try {
    // 機材名セルの幅を取得 
    const equipmentNameCell = document.querySelector('.gantt-item');
    const equipmentNameCellWidth = equipmentNameCell ? equipmentNameCell.offsetWidth : 250;
    
    // バーの位置とサイズを計算
    const width = ((endIdx - startIdx) + 1) * cellWidth;
    const left = startIdx * cellWidth;
    const top = layer * 40 + 10; // 10pxの余白を追加
    
    // バー要素作成
    const bar = document.createElement('div');
    bar.className = 'rental-bar';
    bar.style.position = 'absolute';
    bar.style.left = left + 'px';
    bar.style.top = top + 'px';
    bar.style.width = width + 'px';
    bar.style.height = '40px'; // 高さを統一
    bar.style.borderRadius = '3px';
    bar.style.color = 'white';
    bar.style.padding = '5px 30px 5px 5px';
    bar.style.fontSize = '16px'; // フォントサイズ統一
    bar.style.zIndex = '15'; // 機材名セルより低いZ-index
    bar.style.cursor = 'pointer';
    bar.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
    bar.style.overflow = 'hidden';
    bar.style.textOverflow = 'ellipsis';
    bar.style.whiteSpace = 'nowrap';
    bar.style.display = 'flex';
    bar.style.alignItems = 'center';

    // バーデータとテキスト
    bar.dataset.rentalId = rental['登録日時'] ? rental['登録日時'].toString() : '';
    bar.dataset.layer = layer;
    bar.dataset.location = rental['貸出元'] || '';
    bar.dataset.originalLeft = left; // 元の位置を保存

    // 貸出情報を表示
    bar.textContent = `${rental['数量']}台-${rental['使用場所']}(${getUserDisplayName(rental['借用者'])})`;
    
    // 定置場所と使用場所に基づいて色を決定
    const location = rental['貸出元'] || '';
    if (location && rental['使用場所'] && location === rental['使用場所']) {
      // 同じ場所の場合は緑色
      bar.style.backgroundColor = '#26a69a';
    } else {
      // 異なる場所の場合はオレンジ色
      bar.style.backgroundColor = '#ff9800';
    }

    // ドラッグ＆リサイズ機能を有効化
    enableBarDragAndResize(bar, rental);

    // タイムラインに追加
    timeline.appendChild(bar);
    
    return bar;
  } catch (error) {
    console.error('貸出バー作成エラー:', error);
    return null;
  }
}
// カスタムCSSスタイルをヘッドに追加
function addCustomMobileStyles() {
  const styleElement = document.createElement('style');
  styleElement.textContent = `
    /* モバイル表示での機材名カラム固定強化 */
    body.mobile-view .gantt-item {
      position: sticky !important;
      left: 0 !important;
      z-index: 20 !important;
      background-color: #fff !important;
      border-right: 2px solid #26a69a !important;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2) !important;
    }
    
    /* スワイプ中の機材名カラム固定 */
    body.swiping .gantt-item, 
    body.mobile-view .gantt-item.swipe-fixed {
      transform: none !important;
      transition: none !important;
      position: sticky !important;
      left: 0 !important;
      z-index: 20 !important;
    }
    
    /* タイムラインの調整 */
    body.mobile-view .gantt-timeline {
      margin-left: 0 !important;
      padding-left: 0 !important;
      overflow-x: auto !important;
      -webkit-overflow-scrolling: touch !important;
      scroll-behavior: smooth !important;
    }
    
    /* 日付ヘッダーの調整 */
    body.mobile-view #date-headers {
      margin-left: 0 !important;
      padding-left: 0 !important;
      overflow-x: auto !important;
      -webkit-overflow-scrolling: touch !important;
      scroll-behavior: smooth !important;
    }
    
    /* ヘッダー行の機材名セル */
    body.mobile-view .gantt-header .gantt-item {
      background-color: #f5f5f5 !important;
      z-index: 31 !important;
    }
    
    /* スクロールバー非表示（iOS向け） */
    body.mobile-view .gantt-dates::-webkit-scrollbar,
    body.mobile-view .gantt-timeline::-webkit-scrollbar {
      display: none !important;
    }
    
    /* 貸出バーのスタイル調整 */
    body.mobile-view .rental-bar {
      min-height: 40px !important;
      height: 40px !important;
      display: flex !important;
      align-items: center !important;
      font-size: 16px !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
      z-index: 15 !important;
    }
    
    /* 貸出バー内の返却ボタン */
    body.mobile-view .return-button {
      position: absolute !important;
      right: 5px !important;
      top: 50% !important;
      transform: translateY(-50%) !important;
      width: 30px !important;
      height: 30px !important;
      min-width: 30px !important;
      min-height: 30px !important;
      padding: 0 !important;
      z-index: 16 !important;
    }
    
    body.mobile-view .return-button i.material-icons {
      font-size: 18px !important;
      line-height: 30px !important;
    }
    
    /* 選択行のスタイル */
    body.mobile-view .selected-equipment .gantt-item {
      background-color: #e3f2fd !important;
    }
    
    /* 日付セルのサイズ統一 */
    body.mobile-view .gantt-date,
    body.mobile-view .gantt-day {
      flex: 0 0 80px !important;
      min-width: 80px !important;
      width: 80px !important;
    }
    
    /* スクロール中の動作改善 */
    body.mobile-view .gantt-container {
      overscroll-behavior: none !important;
    }
    
    body.mobile-view .gantt-dates,
    body.mobile-view .gantt-timeline {
      overscroll-behavior: none !important;
      -webkit-overflow-scrolling: touch !important;
    }
  `;
  document.head.appendChild(styleElement);
}
// 月単位で移動
function moveCalendarByMonths(months) {
  // 現在の開始日
  const currentDate = new Date(startDate);
  
  // 月を移動
  currentDate.setMonth(currentDate.getMonth() + months);
  
  // 開始日を更新
  startDate = currentDate;
  startDate.setHours(0, 0, 0, 0);
  
  // ガントチャート更新
  updateGanttChart();
  
  // 新しい月の開始位置に表示
  setTimeout(() => {
    const dateHeaders = document.getElementById('date-headers');
    if (dateHeaders) {
      dateHeaders.scrollLeft = 0;
      
      // タイムラインも同期
      const timelines = document.querySelectorAll('.gantt-timeline');
      timelines.forEach(timeline => {
        timeline.scrollLeft = 0;
      });
      
      // スライダーも同期
      const slider = document.getElementById('date-slider');
      if (slider) {
        slider.value = 0;
      }
      
      // スクロール位置を保存
      savedScrollPosition.left = 0;
    }
  }, 100);
}
</script>